// Code generated by furo protoc-gen-open-models. DO NOT EDIT.
// protoc-gen-open-models version: ????

import {
  ARRAY,
  FieldNode,
  Registry,
  STRING,
} from '@furo/open-models/dist/index';
import {
  CustomHttpPattern as GoogleApiCustomHttpPattern,
  ICustomHttpPattern as IGoogleApiCustomHttpPattern,
  TCustomHttpPattern as TGoogleApiCustomHttpPattern,
} from './CustomHttpPattern';

/**
 * @interface IHttpRule
 *  # gRPC Transcoding
 *
 *  gRPC Transcoding is a feature for mapping between a gRPC method and one or
 *  more HTTP REST endpoints. It allows developers to build a single API service
 *  that supports both gRPC APIs and REST APIs. Many systems, including [Google
 *  APIs](https://github.com/googleapis/googleapis),
 *  [Cloud Endpoints](https://cloud.google.com/endpoints), [gRPC
 *  Gateway](https://github.com/grpc-ecosystem/grpc-gateway),
 *  and [Envoy](https://github.com/envoyproxy/envoy) proxy support this feature
 *  and use it for large scale production services.
 *
 *  `HttpRule` defines the schema of the gRPC/REST mapping. The mapping specifies
 *  how different portions of the gRPC request message are mapped to the URL
 *  path, URL query parameters, and HTTP request body. It also controls how the
 *  gRPC response message is mapped to the HTTP response body. `HttpRule` is
 *  typically specified as an `google.api.http` annotation on the gRPC method.
 *
 *  Each mapping specifies a URL path template and an HTTP method. The path
 *  template may refer to one or more fields in the gRPC request message, as long
 *  as each field is a non-repeated field with a primitive (non-message) type.
 *  The path template controls how fields of the request message are mapped to
 *  the URL path.
 *
 *  Example:
 *
 *      service Messaging {
 *        rpc GetMessage(GetMessageRequest) returns (Message) {
 *          option (google.api.http) = {
 *              get: "/v1/{name=messages/*}"
 *          };
 *        }
 *      }
 *      message GetMessageRequest {
 *        string name = 1; // Mapped to URL path.
 *      }
 *      message Message {
 *        string text = 1; // The resource content.
 *      }
 *
 *  This enables an HTTP REST to gRPC mapping as below:
 *
 *  HTTP | gRPC
 *  -----|-----
 *  `GET /v1/messages/123456`  | `GetMessage(name: "messages/123456")`
 *
 *  Any fields in the request message which are not bound by the path template
 *  automatically become HTTP query parameters if there is no HTTP request body.
 *  For example:
 *
 *      service Messaging {
 *        rpc GetMessage(GetMessageRequest) returns (Message) {
 *          option (google.api.http) = {
 *              get:"/v1/messages/{message_id}"
 *          };
 *        }
 *      }
 *      message GetMessageRequest {
 *        message SubMessage {
 *          string subfield = 1;
 *        }
 *        string message_id = 1; // Mapped to URL path.
 *        int64 revision = 2;    // Mapped to URL query parameter `revision`.
 *        SubMessage sub = 3;    // Mapped to URL query parameter `sub.subfield`.
 *      }
 *
 *  This enables a HTTP JSON to RPC mapping as below:
 *
 *  HTTP | gRPC
 *  -----|-----
 *  `GET /v1/messages/123456?revision=2&sub.subfield=foo` |
 *  `GetMessage(message_id: "123456" revision: 2 sub: SubMessage(subfield:
 *  "foo"))`
 *
 *  Note that fields which are mapped to URL query parameters must have a
 *  primitive type or a repeated primitive type or a non-repeated message type.
 *  In the case of a repeated type, the parameter can be repeated in the URL
 *  as `...?param=A&param=B`. In the case of a message type, each field of the
 *  message is mapped to a separate parameter, such as
 *  `...?foo.a=A&foo.b=B&foo.c=C`.
 *
 *  For HTTP methods that allow a request body, the `body` field
 *  specifies the mapping. Consider a REST update method on the
 *  message resource collection:
 *
 *      service Messaging {
 *        rpc UpdateMessage(UpdateMessageRequest) returns (Message) {
 *          option (google.api.http) = {
 *            patch: "/v1/messages/{message_id}"
 *            body: "message"
 *          };
 *        }
 *      }
 *      message UpdateMessageRequest {
 *        string message_id = 1; // mapped to the URL
 *        Message message = 2;   // mapped to the body
 *      }
 *
 *  The following HTTP JSON to RPC mapping is enabled, where the
 *  representation of the JSON in the request body is determined by
 *  protos JSON encoding:
 *
 *  HTTP | gRPC
 *  -----|-----
 *  `PATCH /v1/messages/123456 { "text": "Hi!" }` | `UpdateMessage(message_id:
 *  "123456" message { text: "Hi!" })`
 *
 *  The special name `*` can be used in the body mapping to define that
 *  every field not bound by the path template should be mapped to the
 *  request body.  This enables the following alternative definition of
 *  the update method:
 *
 *      service Messaging {
 *        rpc UpdateMessage(Message) returns (Message) {
 *          option (google.api.http) = {
 *            patch: "/v1/messages/{message_id}"
 *            body: "*"
 *          };
 *        }
 *      }
 *      message Message {
 *        string message_id = 1;
 *        string text = 2;
 *      }
 *
 *
 *  The following HTTP JSON to RPC mapping is enabled:
 *
 *  HTTP | gRPC
 *  -----|-----
 *  `PATCH /v1/messages/123456 { "text": "Hi!" }` | `UpdateMessage(message_id:
 *  "123456" text: "Hi!")`
 *
 *  Note that when using `*` in the body mapping, it is not possible to
 *  have HTTP parameters, as all fields not bound by the path end in
 *  the body. This makes this option more rarely used in practice when
 *  defining REST APIs. The common usage of `*` is in custom methods
 *  which don't use the URL at all for transferring data.
 *
 *  It is possible to define multiple HTTP methods for one RPC by using
 *  the `additional_bindings` option. Example:
 *
 *      service Messaging {
 *        rpc GetMessage(GetMessageRequest) returns (Message) {
 *          option (google.api.http) = {
 *            get: "/v1/messages/{message_id}"
 *            additional_bindings {
 *              get: "/v1/users/{user_id}/messages/{message_id}"
 *            }
 *          };
 *        }
 *      }
 *      message GetMessageRequest {
 *        string message_id = 1;
 *        string user_id = 2;
 *      }
 *
 *  This enables the following two alternative HTTP JSON to RPC mappings:
 *
 *  HTTP | gRPC
 *  -----|-----
 *  `GET /v1/messages/123456` | `GetMessage(message_id: "123456")`
 *  `GET /v1/users/me/messages/123456` | `GetMessage(user_id: "me" message_id:
 *  "123456")`
 *
 *  ## Rules for HTTP mapping
 *
 *  1. Leaf request fields (recursive expansion nested messages in the request
 *     message) are classified into three categories:
 *     - Fields referred by the path template. They are passed via the URL path.
 *     - Fields referred by the [HttpRule.body][google.api.HttpRule.body]. They
 *     are passed via the HTTP
 *       request body.
 *     - All other fields are passed via the URL query parameters, and the
 *       parameter name is the field path in the request message. A repeated
 *       field can be represented as multiple query parameters under the same
 *       name.
 *   2. If [HttpRule.body][google.api.HttpRule.body] is "*", there is no URL
 *   query parameter, all fields
 *      are passed via URL path and HTTP request body.
 *   3. If [HttpRule.body][google.api.HttpRule.body] is omitted, there is no HTTP
 *   request body, all
 *      fields are passed via URL path and URL query parameters.
 *
 *  ### Path template syntax
 *
 *      Template = "/" Segments [ Verb ] ;
 *      Segments = Segment { "/" Segment } ;
 *      Segment  = "*" | "**" | LITERAL | Variable ;
 *      Variable = "{" FieldPath [ "=" Segments ] "}" ;
 *      FieldPath = IDENT { "." IDENT } ;
 *      Verb     = ":" LITERAL ;
 *
 *  The syntax `*` matches a single URL path segment. The syntax `**` matches
 *  zero or more URL path segments, which must be the last part of the URL path
 *  except the `Verb`.
 *
 *  The syntax `Variable` matches part of the URL path as specified by its
 *  template. A variable template must not contain other variables. If a variable
 *  matches a single path segment, its template may be omitted, e.g. `{var}`
 *  is equivalent to `{var=*}`.
 *
 *  The syntax `LITERAL` matches literal text in the URL path. If the `LITERAL`
 *  contains any reserved character, such characters should be percent-encoded
 *  before the matching.
 *
 *  If a variable contains exactly one path segment, such as `"{var}"` or
 *  `"{var=*}"`, when such a variable is expanded into a URL path on the client
 *  side, all characters except `[-_.~0-9a-zA-Z]` are percent-encoded. The
 *  server side does the reverse decoding. Such variables show up in the
 *  [Discovery
 *  Document](https://developers.google.com/discovery/v1/reference/apis) as
 *  `{var}`.
 *
 *  If a variable contains multiple path segments, such as `"{var=foo/*}"`
 *  or `"{var=**}"`, when such a variable is expanded into a URL path on the
 *  client side, all characters except `[-_.~/0-9a-zA-Z]` are percent-encoded.
 *  The server side does the reverse decoding, except "%2F" and "%2f" are left
 *  unchanged. Such variables show up in the
 *  [Discovery
 *  Document](https://developers.google.com/discovery/v1/reference/apis) as
 *  `{+var}`.
 *
 *  ## Using gRPC API Service Configuration
 *
 *  gRPC API Service Configuration (service config) is a configuration language
 *  for configuring a gRPC service to become a user-facing product. The
 *  service config is simply the YAML representation of the `google.api.Service`
 *  proto message.
 *
 *  As an alternative to annotating your proto file, you can configure gRPC
 *  transcoding in your service config YAML files. You do this by specifying a
 *  `HttpRule` that maps the gRPC method to a REST endpoint, achieving the same
 *  effect as the proto annotation. This can be particularly useful if you
 *  have a proto that is reused in multiple services. Note that any transcoding
 *  specified in the service config will override any matching transcoding
 *  configuration in the proto.
 *
 *  Example:
 *
 *      http:
 *        rules:
 *          # Selects a gRPC method and applies HttpRule to it.
 *          - selector: example.v1.Messaging.GetMessage
 *            get: /v1/messages/{message_id}/{sub.subfield}
 *
 *  ## Special notes
 *
 *  When gRPC Transcoding is used to map a gRPC to JSON REST endpoints, the
 *  proto to JSON conversion must follow the [proto3
 *  specification](https://developers.google.com/protocol-buffers/docs/proto3#json).
 *
 *  While the single segment variable follows the semantics of
 *  [RFC 6570](https://tools.ietf.org/html/rfc6570) Section 3.2.2 Simple String
 *  Expansion, the multi segment variable **does not** follow RFC 6570 Section
 *  3.2.3 Reserved Expansion. The reason is that the Reserved Expansion
 *  does not expand special characters like `?` and `#`, which would lead
 *  to invalid URLs. As the result, gRPC Transcoding uses a custom encoding
 *  for multi segment variables.
 *
 *  The path variables **must not** refer to any repeated or mapped field,
 *  because client libraries are not capable of handling such variable expansion.
 *
 *  The path variables **must not** capture the leading "/" character. The reason
 *  is that the most common use case "{var}" does not capture the leading "/"
 *  character. For consistency, all path variables must share the same behavior.
 *
 *  Repeated message fields must not be mapped to URL query parameters, because
 *  no client library can support such complicated mapping.
 *
 *  If an API needs to use a JSON array for request or response body, it can map
 *  the request or response body to a repeated field. However, some gRPC
 *  Transcoding implementations may not support this feature.
 */
export interface IHttpRule {
  /**
   *  Selects a method to which this rule applies.
   *
   *  Refer to [selector][google.api.DocumentationRule.selector] for syntax
   *  details.
   */
  selector?: string;
  /**
   *  Maps to HTTP GET. Used for listing and getting information about
   *  resources.
   */
  get?: string;
  /**
   *  Maps to HTTP PUT. Used for replacing a resource.
   */
  put?: string;
  /**
   *  Maps to HTTP POST. Used for creating a resource or performing an action.
   */
  post?: string;
  /**
   *  Maps to HTTP DELETE. Used for deleting a resource.
   */
  delete?: string;
  /**
   *  Maps to HTTP PATCH. Used for updating a resource.
   */
  patch?: string;
  /**
   *  The custom pattern is used for specifying an HTTP method that is not
   *  included in the `pattern` field, such as HEAD, or "*" to leave the
   *  HTTP method unspecified for this rule. The wild-card rule is useful
   *  for services that provide content to Web (HTML) clients.
   */
  custom?: IGoogleApiCustomHttpPattern;
  /**
   *  The name of the request field whose value is mapped to the HTTP request
   *  body, or `*` for mapping all request fields not captured by the path
   *  pattern to the HTTP body, or omitted for not having any HTTP request body.
   *
   *  NOTE: the referred field must be present at the top-level of the request
   *  message type.
   */
  body?: string;
  /**
   *  Optional. The name of the response field whose value is mapped to the HTTP
   *  response body. When omitted, the entire response message will be used
   *  as the HTTP response body.
   *
   *  NOTE: The referred field must be present at the top-level of the response
   *  message type.
   */
  responseBody?: string;
  /**
   *  Additional HTTP bindings for the selector. Nested bindings must
   *  not contain an `additional_bindings` field themselves (that is,
   *  the nesting may only be one level deep).
   */
  additionalBindings?: IHttpRule[];
}

/**
 * @interface THttpRule
 *  # gRPC Transcoding
 *
 *  gRPC Transcoding is a feature for mapping between a gRPC method and one or
 *  more HTTP REST endpoints. It allows developers to build a single API service
 *  that supports both gRPC APIs and REST APIs. Many systems, including [Google
 *  APIs](https://github.com/googleapis/googleapis),
 *  [Cloud Endpoints](https://cloud.google.com/endpoints), [gRPC
 *  Gateway](https://github.com/grpc-ecosystem/grpc-gateway),
 *  and [Envoy](https://github.com/envoyproxy/envoy) proxy support this feature
 *  and use it for large scale production services.
 *
 *  `HttpRule` defines the schema of the gRPC/REST mapping. The mapping specifies
 *  how different portions of the gRPC request message are mapped to the URL
 *  path, URL query parameters, and HTTP request body. It also controls how the
 *  gRPC response message is mapped to the HTTP response body. `HttpRule` is
 *  typically specified as an `google.api.http` annotation on the gRPC method.
 *
 *  Each mapping specifies a URL path template and an HTTP method. The path
 *  template may refer to one or more fields in the gRPC request message, as long
 *  as each field is a non-repeated field with a primitive (non-message) type.
 *  The path template controls how fields of the request message are mapped to
 *  the URL path.
 *
 *  Example:
 *
 *      service Messaging {
 *        rpc GetMessage(GetMessageRequest) returns (Message) {
 *          option (google.api.http) = {
 *              get: "/v1/{name=messages/*}"
 *          };
 *        }
 *      }
 *      message GetMessageRequest {
 *        string name = 1; // Mapped to URL path.
 *      }
 *      message Message {
 *        string text = 1; // The resource content.
 *      }
 *
 *  This enables an HTTP REST to gRPC mapping as below:
 *
 *  HTTP | gRPC
 *  -----|-----
 *  `GET /v1/messages/123456`  | `GetMessage(name: "messages/123456")`
 *
 *  Any fields in the request message which are not bound by the path template
 *  automatically become HTTP query parameters if there is no HTTP request body.
 *  For example:
 *
 *      service Messaging {
 *        rpc GetMessage(GetMessageRequest) returns (Message) {
 *          option (google.api.http) = {
 *              get:"/v1/messages/{message_id}"
 *          };
 *        }
 *      }
 *      message GetMessageRequest {
 *        message SubMessage {
 *          string subfield = 1;
 *        }
 *        string message_id = 1; // Mapped to URL path.
 *        int64 revision = 2;    // Mapped to URL query parameter `revision`.
 *        SubMessage sub = 3;    // Mapped to URL query parameter `sub.subfield`.
 *      }
 *
 *  This enables a HTTP JSON to RPC mapping as below:
 *
 *  HTTP | gRPC
 *  -----|-----
 *  `GET /v1/messages/123456?revision=2&sub.subfield=foo` |
 *  `GetMessage(message_id: "123456" revision: 2 sub: SubMessage(subfield:
 *  "foo"))`
 *
 *  Note that fields which are mapped to URL query parameters must have a
 *  primitive type or a repeated primitive type or a non-repeated message type.
 *  In the case of a repeated type, the parameter can be repeated in the URL
 *  as `...?param=A&param=B`. In the case of a message type, each field of the
 *  message is mapped to a separate parameter, such as
 *  `...?foo.a=A&foo.b=B&foo.c=C`.
 *
 *  For HTTP methods that allow a request body, the `body` field
 *  specifies the mapping. Consider a REST update method on the
 *  message resource collection:
 *
 *      service Messaging {
 *        rpc UpdateMessage(UpdateMessageRequest) returns (Message) {
 *          option (google.api.http) = {
 *            patch: "/v1/messages/{message_id}"
 *            body: "message"
 *          };
 *        }
 *      }
 *      message UpdateMessageRequest {
 *        string message_id = 1; // mapped to the URL
 *        Message message = 2;   // mapped to the body
 *      }
 *
 *  The following HTTP JSON to RPC mapping is enabled, where the
 *  representation of the JSON in the request body is determined by
 *  protos JSON encoding:
 *
 *  HTTP | gRPC
 *  -----|-----
 *  `PATCH /v1/messages/123456 { "text": "Hi!" }` | `UpdateMessage(message_id:
 *  "123456" message { text: "Hi!" })`
 *
 *  The special name `*` can be used in the body mapping to define that
 *  every field not bound by the path template should be mapped to the
 *  request body.  This enables the following alternative definition of
 *  the update method:
 *
 *      service Messaging {
 *        rpc UpdateMessage(Message) returns (Message) {
 *          option (google.api.http) = {
 *            patch: "/v1/messages/{message_id}"
 *            body: "*"
 *          };
 *        }
 *      }
 *      message Message {
 *        string message_id = 1;
 *        string text = 2;
 *      }
 *
 *
 *  The following HTTP JSON to RPC mapping is enabled:
 *
 *  HTTP | gRPC
 *  -----|-----
 *  `PATCH /v1/messages/123456 { "text": "Hi!" }` | `UpdateMessage(message_id:
 *  "123456" text: "Hi!")`
 *
 *  Note that when using `*` in the body mapping, it is not possible to
 *  have HTTP parameters, as all fields not bound by the path end in
 *  the body. This makes this option more rarely used in practice when
 *  defining REST APIs. The common usage of `*` is in custom methods
 *  which don't use the URL at all for transferring data.
 *
 *  It is possible to define multiple HTTP methods for one RPC by using
 *  the `additional_bindings` option. Example:
 *
 *      service Messaging {
 *        rpc GetMessage(GetMessageRequest) returns (Message) {
 *          option (google.api.http) = {
 *            get: "/v1/messages/{message_id}"
 *            additional_bindings {
 *              get: "/v1/users/{user_id}/messages/{message_id}"
 *            }
 *          };
 *        }
 *      }
 *      message GetMessageRequest {
 *        string message_id = 1;
 *        string user_id = 2;
 *      }
 *
 *  This enables the following two alternative HTTP JSON to RPC mappings:
 *
 *  HTTP | gRPC
 *  -----|-----
 *  `GET /v1/messages/123456` | `GetMessage(message_id: "123456")`
 *  `GET /v1/users/me/messages/123456` | `GetMessage(user_id: "me" message_id:
 *  "123456")`
 *
 *  ## Rules for HTTP mapping
 *
 *  1. Leaf request fields (recursive expansion nested messages in the request
 *     message) are classified into three categories:
 *     - Fields referred by the path template. They are passed via the URL path.
 *     - Fields referred by the [HttpRule.body][google.api.HttpRule.body]. They
 *     are passed via the HTTP
 *       request body.
 *     - All other fields are passed via the URL query parameters, and the
 *       parameter name is the field path in the request message. A repeated
 *       field can be represented as multiple query parameters under the same
 *       name.
 *   2. If [HttpRule.body][google.api.HttpRule.body] is "*", there is no URL
 *   query parameter, all fields
 *      are passed via URL path and HTTP request body.
 *   3. If [HttpRule.body][google.api.HttpRule.body] is omitted, there is no HTTP
 *   request body, all
 *      fields are passed via URL path and URL query parameters.
 *
 *  ### Path template syntax
 *
 *      Template = "/" Segments [ Verb ] ;
 *      Segments = Segment { "/" Segment } ;
 *      Segment  = "*" | "**" | LITERAL | Variable ;
 *      Variable = "{" FieldPath [ "=" Segments ] "}" ;
 *      FieldPath = IDENT { "." IDENT } ;
 *      Verb     = ":" LITERAL ;
 *
 *  The syntax `*` matches a single URL path segment. The syntax `**` matches
 *  zero or more URL path segments, which must be the last part of the URL path
 *  except the `Verb`.
 *
 *  The syntax `Variable` matches part of the URL path as specified by its
 *  template. A variable template must not contain other variables. If a variable
 *  matches a single path segment, its template may be omitted, e.g. `{var}`
 *  is equivalent to `{var=*}`.
 *
 *  The syntax `LITERAL` matches literal text in the URL path. If the `LITERAL`
 *  contains any reserved character, such characters should be percent-encoded
 *  before the matching.
 *
 *  If a variable contains exactly one path segment, such as `"{var}"` or
 *  `"{var=*}"`, when such a variable is expanded into a URL path on the client
 *  side, all characters except `[-_.~0-9a-zA-Z]` are percent-encoded. The
 *  server side does the reverse decoding. Such variables show up in the
 *  [Discovery
 *  Document](https://developers.google.com/discovery/v1/reference/apis) as
 *  `{var}`.
 *
 *  If a variable contains multiple path segments, such as `"{var=foo/*}"`
 *  or `"{var=**}"`, when such a variable is expanded into a URL path on the
 *  client side, all characters except `[-_.~/0-9a-zA-Z]` are percent-encoded.
 *  The server side does the reverse decoding, except "%2F" and "%2f" are left
 *  unchanged. Such variables show up in the
 *  [Discovery
 *  Document](https://developers.google.com/discovery/v1/reference/apis) as
 *  `{+var}`.
 *
 *  ## Using gRPC API Service Configuration
 *
 *  gRPC API Service Configuration (service config) is a configuration language
 *  for configuring a gRPC service to become a user-facing product. The
 *  service config is simply the YAML representation of the `google.api.Service`
 *  proto message.
 *
 *  As an alternative to annotating your proto file, you can configure gRPC
 *  transcoding in your service config YAML files. You do this by specifying a
 *  `HttpRule` that maps the gRPC method to a REST endpoint, achieving the same
 *  effect as the proto annotation. This can be particularly useful if you
 *  have a proto that is reused in multiple services. Note that any transcoding
 *  specified in the service config will override any matching transcoding
 *  configuration in the proto.
 *
 *  Example:
 *
 *      http:
 *        rules:
 *          # Selects a gRPC method and applies HttpRule to it.
 *          - selector: example.v1.Messaging.GetMessage
 *            get: /v1/messages/{message_id}/{sub.subfield}
 *
 *  ## Special notes
 *
 *  When gRPC Transcoding is used to map a gRPC to JSON REST endpoints, the
 *  proto to JSON conversion must follow the [proto3
 *  specification](https://developers.google.com/protocol-buffers/docs/proto3#json).
 *
 *  While the single segment variable follows the semantics of
 *  [RFC 6570](https://tools.ietf.org/html/rfc6570) Section 3.2.2 Simple String
 *  Expansion, the multi segment variable **does not** follow RFC 6570 Section
 *  3.2.3 Reserved Expansion. The reason is that the Reserved Expansion
 *  does not expand special characters like `?` and `#`, which would lead
 *  to invalid URLs. As the result, gRPC Transcoding uses a custom encoding
 *  for multi segment variables.
 *
 *  The path variables **must not** refer to any repeated or mapped field,
 *  because client libraries are not capable of handling such variable expansion.
 *
 *  The path variables **must not** capture the leading "/" character. The reason
 *  is that the most common use case "{var}" does not capture the leading "/"
 *  character. For consistency, all path variables must share the same behavior.
 *
 *  Repeated message fields must not be mapped to URL query parameters, because
 *  no client library can support such complicated mapping.
 *
 *  If an API needs to use a JSON array for request or response body, it can map
 *  the request or response body to a repeated field. However, some gRPC
 *  Transcoding implementations may not support this feature.
 */
export interface THttpRule {
  /**
   *  Selects a method to which this rule applies.
   *
   *  Refer to [selector][google.api.DocumentationRule.selector] for syntax
   *  details.
   */
  selector?: string;
  /**
   *  Maps to HTTP GET. Used for listing and getting information about
   *  resources.
   */
  get?: string;
  /**
   *  Maps to HTTP PUT. Used for replacing a resource.
   */
  put?: string;
  /**
   *  Maps to HTTP POST. Used for creating a resource or performing an action.
   */
  post?: string;
  /**
   *  Maps to HTTP DELETE. Used for deleting a resource.
   */
  delete?: string;
  /**
   *  Maps to HTTP PATCH. Used for updating a resource.
   */
  patch?: string;
  /**
   *  The custom pattern is used for specifying an HTTP method that is not
   *  included in the `pattern` field, such as HEAD, or "*" to leave the
   *  HTTP method unspecified for this rule. The wild-card rule is useful
   *  for services that provide content to Web (HTML) clients.
   */
  custom?: TGoogleApiCustomHttpPattern;
  /**
   *  The name of the request field whose value is mapped to the HTTP request
   *  body, or `*` for mapping all request fields not captured by the path
   *  pattern to the HTTP body, or omitted for not having any HTTP request body.
   *
   *  NOTE: the referred field must be present at the top-level of the request
   *  message type.
   */
  body?: string;
  /**
   *  Optional. The name of the response field whose value is mapped to the HTTP
   *  response body. When omitted, the entire response message will be used
   *  as the HTTP response body.
   *
   *  NOTE: The referred field must be present at the top-level of the response
   *  message type.
   */
  response_body?: string;
  /**
   *  Additional HTTP bindings for the selector. Nested bindings must
   *  not contain an `additional_bindings` field themselves (that is,
   *  the nesting may only be one level deep).
   */
  additional_bindings?: THttpRule[];
}

/**
 * HttpRule
 *  # gRPC Transcoding
 *
 *  gRPC Transcoding is a feature for mapping between a gRPC method and one or
 *  more HTTP REST endpoints. It allows developers to build a single API service
 *  that supports both gRPC APIs and REST APIs. Many systems, including [Google
 *  APIs](https://github.com/googleapis/googleapis),
 *  [Cloud Endpoints](https://cloud.google.com/endpoints), [gRPC
 *  Gateway](https://github.com/grpc-ecosystem/grpc-gateway),
 *  and [Envoy](https://github.com/envoyproxy/envoy) proxy support this feature
 *  and use it for large scale production services.
 *
 *  `HttpRule` defines the schema of the gRPC/REST mapping. The mapping specifies
 *  how different portions of the gRPC request message are mapped to the URL
 *  path, URL query parameters, and HTTP request body. It also controls how the
 *  gRPC response message is mapped to the HTTP response body. `HttpRule` is
 *  typically specified as an `google.api.http` annotation on the gRPC method.
 *
 *  Each mapping specifies a URL path template and an HTTP method. The path
 *  template may refer to one or more fields in the gRPC request message, as long
 *  as each field is a non-repeated field with a primitive (non-message) type.
 *  The path template controls how fields of the request message are mapped to
 *  the URL path.
 *
 *  Example:
 *
 *      service Messaging {
 *        rpc GetMessage(GetMessageRequest) returns (Message) {
 *          option (google.api.http) = {
 *              get: "/v1/{name=messages/*}"
 *          };
 *        }
 *      }
 *      message GetMessageRequest {
 *        string name = 1; // Mapped to URL path.
 *      }
 *      message Message {
 *        string text = 1; // The resource content.
 *      }
 *
 *  This enables an HTTP REST to gRPC mapping as below:
 *
 *  HTTP | gRPC
 *  -----|-----
 *  `GET /v1/messages/123456`  | `GetMessage(name: "messages/123456")`
 *
 *  Any fields in the request message which are not bound by the path template
 *  automatically become HTTP query parameters if there is no HTTP request body.
 *  For example:
 *
 *      service Messaging {
 *        rpc GetMessage(GetMessageRequest) returns (Message) {
 *          option (google.api.http) = {
 *              get:"/v1/messages/{message_id}"
 *          };
 *        }
 *      }
 *      message GetMessageRequest {
 *        message SubMessage {
 *          string subfield = 1;
 *        }
 *        string message_id = 1; // Mapped to URL path.
 *        int64 revision = 2;    // Mapped to URL query parameter `revision`.
 *        SubMessage sub = 3;    // Mapped to URL query parameter `sub.subfield`.
 *      }
 *
 *  This enables a HTTP JSON to RPC mapping as below:
 *
 *  HTTP | gRPC
 *  -----|-----
 *  `GET /v1/messages/123456?revision=2&sub.subfield=foo` |
 *  `GetMessage(message_id: "123456" revision: 2 sub: SubMessage(subfield:
 *  "foo"))`
 *
 *  Note that fields which are mapped to URL query parameters must have a
 *  primitive type or a repeated primitive type or a non-repeated message type.
 *  In the case of a repeated type, the parameter can be repeated in the URL
 *  as `...?param=A&param=B`. In the case of a message type, each field of the
 *  message is mapped to a separate parameter, such as
 *  `...?foo.a=A&foo.b=B&foo.c=C`.
 *
 *  For HTTP methods that allow a request body, the `body` field
 *  specifies the mapping. Consider a REST update method on the
 *  message resource collection:
 *
 *      service Messaging {
 *        rpc UpdateMessage(UpdateMessageRequest) returns (Message) {
 *          option (google.api.http) = {
 *            patch: "/v1/messages/{message_id}"
 *            body: "message"
 *          };
 *        }
 *      }
 *      message UpdateMessageRequest {
 *        string message_id = 1; // mapped to the URL
 *        Message message = 2;   // mapped to the body
 *      }
 *
 *  The following HTTP JSON to RPC mapping is enabled, where the
 *  representation of the JSON in the request body is determined by
 *  protos JSON encoding:
 *
 *  HTTP | gRPC
 *  -----|-----
 *  `PATCH /v1/messages/123456 { "text": "Hi!" }` | `UpdateMessage(message_id:
 *  "123456" message { text: "Hi!" })`
 *
 *  The special name `*` can be used in the body mapping to define that
 *  every field not bound by the path template should be mapped to the
 *  request body.  This enables the following alternative definition of
 *  the update method:
 *
 *      service Messaging {
 *        rpc UpdateMessage(Message) returns (Message) {
 *          option (google.api.http) = {
 *            patch: "/v1/messages/{message_id}"
 *            body: "*"
 *          };
 *        }
 *      }
 *      message Message {
 *        string message_id = 1;
 *        string text = 2;
 *      }
 *
 *
 *  The following HTTP JSON to RPC mapping is enabled:
 *
 *  HTTP | gRPC
 *  -----|-----
 *  `PATCH /v1/messages/123456 { "text": "Hi!" }` | `UpdateMessage(message_id:
 *  "123456" text: "Hi!")`
 *
 *  Note that when using `*` in the body mapping, it is not possible to
 *  have HTTP parameters, as all fields not bound by the path end in
 *  the body. This makes this option more rarely used in practice when
 *  defining REST APIs. The common usage of `*` is in custom methods
 *  which don't use the URL at all for transferring data.
 *
 *  It is possible to define multiple HTTP methods for one RPC by using
 *  the `additional_bindings` option. Example:
 *
 *      service Messaging {
 *        rpc GetMessage(GetMessageRequest) returns (Message) {
 *          option (google.api.http) = {
 *            get: "/v1/messages/{message_id}"
 *            additional_bindings {
 *              get: "/v1/users/{user_id}/messages/{message_id}"
 *            }
 *          };
 *        }
 *      }
 *      message GetMessageRequest {
 *        string message_id = 1;
 *        string user_id = 2;
 *      }
 *
 *  This enables the following two alternative HTTP JSON to RPC mappings:
 *
 *  HTTP | gRPC
 *  -----|-----
 *  `GET /v1/messages/123456` | `GetMessage(message_id: "123456")`
 *  `GET /v1/users/me/messages/123456` | `GetMessage(user_id: "me" message_id:
 *  "123456")`
 *
 *  ## Rules for HTTP mapping
 *
 *  1. Leaf request fields (recursive expansion nested messages in the request
 *     message) are classified into three categories:
 *     - Fields referred by the path template. They are passed via the URL path.
 *     - Fields referred by the [HttpRule.body][google.api.HttpRule.body]. They
 *     are passed via the HTTP
 *       request body.
 *     - All other fields are passed via the URL query parameters, and the
 *       parameter name is the field path in the request message. A repeated
 *       field can be represented as multiple query parameters under the same
 *       name.
 *   2. If [HttpRule.body][google.api.HttpRule.body] is "*", there is no URL
 *   query parameter, all fields
 *      are passed via URL path and HTTP request body.
 *   3. If [HttpRule.body][google.api.HttpRule.body] is omitted, there is no HTTP
 *   request body, all
 *      fields are passed via URL path and URL query parameters.
 *
 *  ### Path template syntax
 *
 *      Template = "/" Segments [ Verb ] ;
 *      Segments = Segment { "/" Segment } ;
 *      Segment  = "*" | "**" | LITERAL | Variable ;
 *      Variable = "{" FieldPath [ "=" Segments ] "}" ;
 *      FieldPath = IDENT { "." IDENT } ;
 *      Verb     = ":" LITERAL ;
 *
 *  The syntax `*` matches a single URL path segment. The syntax `**` matches
 *  zero or more URL path segments, which must be the last part of the URL path
 *  except the `Verb`.
 *
 *  The syntax `Variable` matches part of the URL path as specified by its
 *  template. A variable template must not contain other variables. If a variable
 *  matches a single path segment, its template may be omitted, e.g. `{var}`
 *  is equivalent to `{var=*}`.
 *
 *  The syntax `LITERAL` matches literal text in the URL path. If the `LITERAL`
 *  contains any reserved character, such characters should be percent-encoded
 *  before the matching.
 *
 *  If a variable contains exactly one path segment, such as `"{var}"` or
 *  `"{var=*}"`, when such a variable is expanded into a URL path on the client
 *  side, all characters except `[-_.~0-9a-zA-Z]` are percent-encoded. The
 *  server side does the reverse decoding. Such variables show up in the
 *  [Discovery
 *  Document](https://developers.google.com/discovery/v1/reference/apis) as
 *  `{var}`.
 *
 *  If a variable contains multiple path segments, such as `"{var=foo/*}"`
 *  or `"{var=**}"`, when such a variable is expanded into a URL path on the
 *  client side, all characters except `[-_.~/0-9a-zA-Z]` are percent-encoded.
 *  The server side does the reverse decoding, except "%2F" and "%2f" are left
 *  unchanged. Such variables show up in the
 *  [Discovery
 *  Document](https://developers.google.com/discovery/v1/reference/apis) as
 *  `{+var}`.
 *
 *  ## Using gRPC API Service Configuration
 *
 *  gRPC API Service Configuration (service config) is a configuration language
 *  for configuring a gRPC service to become a user-facing product. The
 *  service config is simply the YAML representation of the `google.api.Service`
 *  proto message.
 *
 *  As an alternative to annotating your proto file, you can configure gRPC
 *  transcoding in your service config YAML files. You do this by specifying a
 *  `HttpRule` that maps the gRPC method to a REST endpoint, achieving the same
 *  effect as the proto annotation. This can be particularly useful if you
 *  have a proto that is reused in multiple services. Note that any transcoding
 *  specified in the service config will override any matching transcoding
 *  configuration in the proto.
 *
 *  Example:
 *
 *      http:
 *        rules:
 *          # Selects a gRPC method and applies HttpRule to it.
 *          - selector: example.v1.Messaging.GetMessage
 *            get: /v1/messages/{message_id}/{sub.subfield}
 *
 *  ## Special notes
 *
 *  When gRPC Transcoding is used to map a gRPC to JSON REST endpoints, the
 *  proto to JSON conversion must follow the [proto3
 *  specification](https://developers.google.com/protocol-buffers/docs/proto3#json).
 *
 *  While the single segment variable follows the semantics of
 *  [RFC 6570](https://tools.ietf.org/html/rfc6570) Section 3.2.2 Simple String
 *  Expansion, the multi segment variable **does not** follow RFC 6570 Section
 *  3.2.3 Reserved Expansion. The reason is that the Reserved Expansion
 *  does not expand special characters like `?` and `#`, which would lead
 *  to invalid URLs. As the result, gRPC Transcoding uses a custom encoding
 *  for multi segment variables.
 *
 *  The path variables **must not** refer to any repeated or mapped field,
 *  because client libraries are not capable of handling such variable expansion.
 *
 *  The path variables **must not** capture the leading "/" character. The reason
 *  is that the most common use case "{var}" does not capture the leading "/"
 *  character. For consistency, all path variables must share the same behavior.
 *
 *  Repeated message fields must not be mapped to URL query parameters, because
 *  no client library can support such complicated mapping.
 *
 *  If an API needs to use a JSON array for request or response body, it can map
 *  the request or response body to a repeated field. However, some gRPC
 *  Transcoding implementations may not support this feature.
 */
export class HttpRule extends FieldNode {
  //  Selects a method to which this rule applies.
  //
  //  Refer to [selector][google.api.DocumentationRule.selector] for syntax
  //  details.
  private _selector: STRING;

  //  Maps to HTTP GET. Used for listing and getting information about
  //  resources.
  private _get: STRING;

  //  Maps to HTTP PUT. Used for replacing a resource.
  private _put: STRING;

  //  Maps to HTTP POST. Used for creating a resource or performing an action.
  private _post: STRING;

  //  Maps to HTTP DELETE. Used for deleting a resource.
  private _delete: STRING;

  //  Maps to HTTP PATCH. Used for updating a resource.
  private _patch: STRING;

  //  The custom pattern is used for specifying an HTTP method that is not
  //  included in the `pattern` field, such as HEAD, or "*" to leave the
  //  HTTP method unspecified for this rule. The wild-card rule is useful
  //  for services that provide content to Web (HTML) clients.
  private _custom: GoogleApiCustomHttpPattern;

  //  The name of the request field whose value is mapped to the HTTP request
  //  body, or `*` for mapping all request fields not captured by the path
  //  pattern to the HTTP body, or omitted for not having any HTTP request body.
  //
  //  NOTE: the referred field must be present at the top-level of the request
  //  message type.
  private _body: STRING;

  //  Optional. The name of the response field whose value is mapped to the HTTP
  //  response body. When omitted, the entire response message will be used
  //  as the HTTP response body.
  //
  //  NOTE: The referred field must be present at the top-level of the response
  //  message type.
  private _responseBody: STRING;

  //  Additional HTTP bindings for the selector. Nested bindings must
  //  not contain an `additional_bindings` field themselves (that is,
  //  the nesting may only be one level deep).
  private _additionalBindings: ARRAY<HttpRule, IHttpRule>;

  public __defaultValues: IHttpRule;

  constructor(
    initData?: IHttpRule,
    parent?: FieldNode,
    parentAttributeName?: string,
  ) {
    super(undefined, parent, parentAttributeName);
    this.__meta.typeName = 'google.api.HttpRule';

    this.__meta.nodeFields = [
      {
        fieldName: 'selector',
        protoName: 'selector',
        FieldConstructor: STRING,
        constraints: {},
      },
      {
        fieldName: 'get',
        protoName: 'get',
        FieldConstructor: STRING,
        constraints: {},
      },
      {
        fieldName: 'put',
        protoName: 'put',
        FieldConstructor: STRING,
        constraints: {},
      },
      {
        fieldName: 'post',
        protoName: 'post',
        FieldConstructor: STRING,
        constraints: {},
      },
      {
        fieldName: 'delete',
        protoName: 'delete',
        FieldConstructor: STRING,
        constraints: {},
      },
      {
        fieldName: 'patch',
        protoName: 'patch',
        FieldConstructor: STRING,
        constraints: {},
      },
      {
        fieldName: 'custom',
        protoName: 'custom',
        FieldConstructor: GoogleApiCustomHttpPattern,
        constraints: {},
      },
      {
        fieldName: 'body',
        protoName: 'body',
        FieldConstructor: STRING,
        constraints: {},
      },
      {
        fieldName: 'responseBody',
        protoName: 'response_body',
        FieldConstructor: STRING,
        constraints: {},
      },
      {
        fieldName: 'additionalBindings',
        protoName: 'additional_bindings',
        FieldConstructor: HttpRule,
        constraints: {},
      },
    ];

    // Initialize the fields
    //  Selects a method to which this rule applies.
    //
    //  Refer to [selector][google.api.DocumentationRule.selector] for syntax
    //  details.
    this._selector = new STRING(undefined, this, 'selector');

    //  Maps to HTTP GET. Used for listing and getting information about
    //  resources.
    this._get = new STRING(undefined, this, 'get');

    //  Maps to HTTP PUT. Used for replacing a resource.
    this._put = new STRING(undefined, this, 'put');

    //  Maps to HTTP POST. Used for creating a resource or performing an action.
    this._post = new STRING(undefined, this, 'post');

    //  Maps to HTTP DELETE. Used for deleting a resource.
    this._delete = new STRING(undefined, this, 'delete');

    //  Maps to HTTP PATCH. Used for updating a resource.
    this._patch = new STRING(undefined, this, 'patch');

    //  The custom pattern is used for specifying an HTTP method that is not
    //  included in the `pattern` field, such as HEAD, or "*" to leave the
    //  HTTP method unspecified for this rule. The wild-card rule is useful
    //  for services that provide content to Web (HTML) clients.
    this._custom = new GoogleApiCustomHttpPattern(undefined, this, 'custom');

    //  The name of the request field whose value is mapped to the HTTP request
    //  body, or `*` for mapping all request fields not captured by the path
    //  pattern to the HTTP body, or omitted for not having any HTTP request body.
    //
    //  NOTE: the referred field must be present at the top-level of the request
    //  message type.
    this._body = new STRING(undefined, this, 'body');

    //  Optional. The name of the response field whose value is mapped to the HTTP
    //  response body. When omitted, the entire response message will be used
    //  as the HTTP response body.
    //
    //  NOTE: The referred field must be present at the top-level of the response
    //  message type.
    this._responseBody = new STRING(undefined, this, 'responseBody');

    //  Additional HTTP bindings for the selector. Nested bindings must
    //  not contain an `additional_bindings` field themselves (that is,
    //  the nesting may only be one level deep).
    this._additionalBindings = new ARRAY<HttpRule, IHttpRule>(
      undefined,
      this,
      'additionalBindings',
    );

    // Set required fields
    [].forEach(fieldName => {
      (this[fieldName as keyof HttpRule] as FieldNode).__meta.required = true;
    });

    // Default values from openAPI annotations
    this.__defaultValues = {};

    // Initialize the fields with init data
    if (initData !== undefined) {
      this.__fromLiteral({ ...this.__defaultValues, ...initData });
    } else {
      this.__fromLiteral(this.__defaultValues);
    }

    // Set readonly fields after the init, so child nodes are readonly too
    [].forEach(fieldName => {
      (this[fieldName as keyof HttpRule] as FieldNode).__readonly = true;
    });

    this.__meta.isPristine = true;
  }

  //  Selects a method to which this rule applies.
  //
  //  Refer to [selector][google.api.DocumentationRule.selector] for syntax
  //  details.
  public get selector(): STRING {
    return this._selector;
  }

  public set selector(v: string) {
    this.__PrimitivesSetter(this._selector, v);
  }

  //  Maps to HTTP GET. Used for listing and getting information about
  //  resources.
  public get get(): STRING {
    return this._get;
  }

  public set get(v: string) {
    this.__PrimitivesSetter(this._get, v);
  }

  //  Maps to HTTP PUT. Used for replacing a resource.
  public get put(): STRING {
    return this._put;
  }

  public set put(v: string) {
    this.__PrimitivesSetter(this._put, v);
  }

  //  Maps to HTTP POST. Used for creating a resource or performing an action.
  public get post(): STRING {
    return this._post;
  }

  public set post(v: string) {
    this.__PrimitivesSetter(this._post, v);
  }

  //  Maps to HTTP DELETE. Used for deleting a resource.
  public get delete(): STRING {
    return this._delete;
  }

  public set delete(v: string) {
    this.__PrimitivesSetter(this._delete, v);
  }

  //  Maps to HTTP PATCH. Used for updating a resource.
  public get patch(): STRING {
    return this._patch;
  }

  public set patch(v: string) {
    this.__PrimitivesSetter(this._patch, v);
  }

  //  The custom pattern is used for specifying an HTTP method that is not
  //  included in the `pattern` field, such as HEAD, or "*" to leave the
  //  HTTP method unspecified for this rule. The wild-card rule is useful
  //  for services that provide content to Web (HTML) clients.
  public get custom(): GoogleApiCustomHttpPattern {
    return this._custom;
  }

  public set custom(v: IGoogleApiCustomHttpPattern) {
    this.__TypeSetter(this._custom, v);
  }

  //  The name of the request field whose value is mapped to the HTTP request
  //  body, or `*` for mapping all request fields not captured by the path
  //  pattern to the HTTP body, or omitted for not having any HTTP request body.
  //
  //  NOTE: the referred field must be present at the top-level of the request
  //  message type.
  public get body(): STRING {
    return this._body;
  }

  public set body(v: string) {
    this.__PrimitivesSetter(this._body, v);
  }

  //  Optional. The name of the response field whose value is mapped to the HTTP
  //  response body. When omitted, the entire response message will be used
  //  as the HTTP response body.
  //
  //  NOTE: The referred field must be present at the top-level of the response
  //  message type.
  public get responseBody(): STRING {
    return this._responseBody;
  }

  public set responseBody(v: string) {
    this.__PrimitivesSetter(this._responseBody, v);
  }

  //  Additional HTTP bindings for the selector. Nested bindings must
  //  not contain an `additional_bindings` field themselves (that is,
  //  the nesting may only be one level deep).
  public get additionalBindings(): ARRAY<HttpRule, IHttpRule> {
    return this._additionalBindings;
  }

  public set additionalBindings(v: IHttpRule[]) {
    this.__TypeSetter(this._additionalBindings, v);
  }

  fromLiteral(data: IHttpRule) {
    super.__fromLiteral(data);
  }

  toLiteral(): IHttpRule {
    return super.__toLiteral();
  }
}

Registry.register('google.api.HttpRule', HttpRule);
