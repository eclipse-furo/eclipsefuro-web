// Code generated by furo protoc-gen-open-models. DO NOT EDIT.
// protoc-gen-open-models version: ????

import { ARRAY, ENUM, FieldNode, Registry } from '@furo/open-models/dist/index';
import {
  ExtensionRangeOptionsDeclaration as GoogleProtobufExtensionRangeOptionsDeclaration,
  IExtensionRangeOptionsDeclaration as IGoogleProtobufExtensionRangeOptionsDeclaration,
  TExtensionRangeOptionsDeclaration as TGoogleProtobufExtensionRangeOptionsDeclaration,
} from './ExtensionRangeOptions.Declaration';

import { ExtensionRangeOptionsVerificationState as GoogleProtobufExtensionRangeOptionsVerificationState } from './ExtensionRangeOptions.VerificationState';

import {
  FeatureSet as GoogleProtobufFeatureSet,
  IFeatureSet as IGoogleProtobufFeatureSet,
  TFeatureSet as TGoogleProtobufFeatureSet,
} from './FeatureSet';

import {
  IUninterpretedOption as IGoogleProtobufUninterpretedOption,
  TUninterpretedOption as TGoogleProtobufUninterpretedOption,
  UninterpretedOption as GoogleProtobufUninterpretedOption,
} from './UninterpretedOption';

/**
 * @interface IExtensionRangeOptions
 */
export interface IExtensionRangeOptions {
  /**
   *  The parser stores options it doesn't recognize here. See above.
   */
  uninterpretedOption?: IGoogleProtobufUninterpretedOption[];
  /**
   *  For external users: DO NOT USE. We are in the process of open sourcing
   *  extension declaration and executing internal cleanups before it can be
   *  used externally.
   */
  declaration?: IGoogleProtobufExtensionRangeOptionsDeclaration[];
  /**
   *  Any features defined in the specific edition.
   */
  features?: IGoogleProtobufFeatureSet;
  /**
   *  The verification state of the range.
   *  TODO: flip the default to DECLARATION once all empty ranges
   *  are marked as UNVERIFIED.
   */
  verification?: GoogleProtobufExtensionRangeOptionsVerificationState | string;
}

/**
 * @interface TExtensionRangeOptions
 */
export interface TExtensionRangeOptions {
  /**
   *  The parser stores options it doesn't recognize here. See above.
   */
  uninterpreted_option?: TGoogleProtobufUninterpretedOption[];
  /**
   *  For external users: DO NOT USE. We are in the process of open sourcing
   *  extension declaration and executing internal cleanups before it can be
   *  used externally.
   */
  declaration?: TGoogleProtobufExtensionRangeOptionsDeclaration[];
  /**
   *  Any features defined in the specific edition.
   */
  features?: TGoogleProtobufFeatureSet;
  /**
   *  The verification state of the range.
   *  TODO: flip the default to DECLARATION once all empty ranges
   *  are marked as UNVERIFIED.
   */
  verification?: GoogleProtobufExtensionRangeOptionsVerificationState | string;
}

/**
 * ExtensionRangeOptions
 */
export class ExtensionRangeOptions extends FieldNode {
  //  The parser stores options it doesn't recognize here. See above.
  private _uninterpretedOption: ARRAY<
    GoogleProtobufUninterpretedOption,
    IGoogleProtobufUninterpretedOption
  >;

  //  For external users: DO NOT USE. We are in the process of open sourcing
  //  extension declaration and executing internal cleanups before it can be
  //  used externally.
  private _declaration: ARRAY<
    GoogleProtobufExtensionRangeOptionsDeclaration,
    IGoogleProtobufExtensionRangeOptionsDeclaration
  >;

  //  Any features defined in the specific edition.
  private _features: GoogleProtobufFeatureSet;

  //  The verification state of the range.
  //  TODO: flip the default to DECLARATION once all empty ranges
  //  are marked as UNVERIFIED.
  private _verification: ENUM<GoogleProtobufExtensionRangeOptionsVerificationState>;

  public __defaultValues: IExtensionRangeOptions;

  constructor(
    initData?: IExtensionRangeOptions,
    parent?: FieldNode,
    parentAttributeName?: string,
  ) {
    super(undefined, parent, parentAttributeName);
    this.__meta.typeName = 'google.protobuf.ExtensionRangeOptions';

    this.__meta.nodeFields = [
      {
        fieldName: 'uninterpretedOption',
        protoName: 'uninterpreted_option',
        FieldConstructor: GoogleProtobufUninterpretedOption,
        constraints: {},
      },
      {
        fieldName: 'declaration',
        protoName: 'declaration',
        FieldConstructor: GoogleProtobufExtensionRangeOptionsDeclaration,
        constraints: {},
      },
      {
        fieldName: 'features',
        protoName: 'features',
        FieldConstructor: GoogleProtobufFeatureSet,
        constraints: {},
      },
      {
        fieldName: 'verification',
        protoName: 'verification',
        FieldConstructor:
          ENUM<GoogleProtobufExtensionRangeOptionsVerificationState>,
        constraints: {},
      },
    ];

    // Initialize the fields
    //  The parser stores options it doesn't recognize here. See above.
    this._uninterpretedOption = new ARRAY<
      GoogleProtobufUninterpretedOption,
      IGoogleProtobufUninterpretedOption
    >(undefined, this, 'uninterpretedOption');

    //  For external users: DO NOT USE. We are in the process of open sourcing
    //  extension declaration and executing internal cleanups before it can be
    //  used externally.
    this._declaration = new ARRAY<
      GoogleProtobufExtensionRangeOptionsDeclaration,
      IGoogleProtobufExtensionRangeOptionsDeclaration
    >(undefined, this, 'declaration');

    //  Any features defined in the specific edition.
    this._features = new GoogleProtobufFeatureSet(undefined, this, 'features');

    //  The verification state of the range.
    //  TODO: flip the default to DECLARATION once all empty ranges
    //  are marked as UNVERIFIED.
    this._verification =
      new ENUM<GoogleProtobufExtensionRangeOptionsVerificationState>(
        undefined,
        GoogleProtobufExtensionRangeOptionsVerificationState,
        GoogleProtobufExtensionRangeOptionsVerificationState.UNVERIFIED,
        this,
        'verification',
      );

    // Set required fields
    [].forEach(fieldName => {
      (
        this[fieldName as keyof ExtensionRangeOptions] as FieldNode
      ).__meta.required = true;
    });

    // Default values from openAPI annotations
    this.__defaultValues = {};

    // Initialize the fields with init data
    if (initData !== undefined) {
      this.__fromLiteral({ ...this.__defaultValues, ...initData });
    } else {
      this.__fromLiteral(this.__defaultValues);
    }

    // Set readonly fields after the init, so child nodes are readonly too
    [].forEach(fieldName => {
      (this[fieldName as keyof ExtensionRangeOptions] as FieldNode).__readonly =
        true;
    });

    this.__meta.isPristine = true;
  }

  //  The parser stores options it doesn't recognize here. See above.
  public get uninterpretedOption(): ARRAY<
    GoogleProtobufUninterpretedOption,
    IGoogleProtobufUninterpretedOption
  > {
    return this._uninterpretedOption;
  }

  public set uninterpretedOption(v: IGoogleProtobufUninterpretedOption[]) {
    this.__TypeSetter(this._uninterpretedOption, v);
  }

  //  For external users: DO NOT USE. We are in the process of open sourcing
  //  extension declaration and executing internal cleanups before it can be
  //  used externally.
  public get declaration(): ARRAY<
    GoogleProtobufExtensionRangeOptionsDeclaration,
    IGoogleProtobufExtensionRangeOptionsDeclaration
  > {
    return this._declaration;
  }

  public set declaration(v: IGoogleProtobufExtensionRangeOptionsDeclaration[]) {
    this.__TypeSetter(this._declaration, v);
  }

  //  Any features defined in the specific edition.
  public get features(): GoogleProtobufFeatureSet {
    return this._features;
  }

  public set features(v: IGoogleProtobufFeatureSet) {
    this.__TypeSetter(this._features, v);
  }

  //  The verification state of the range.
  //  TODO: flip the default to DECLARATION once all empty ranges
  //  are marked as UNVERIFIED.
  public get verification(): ENUM<GoogleProtobufExtensionRangeOptionsVerificationState> {
    return this._verification;
  }

  public set verification(
    v: GoogleProtobufExtensionRangeOptionsVerificationState,
  ) {
    this.__TypeSetter(this._verification, v);
  }

  fromLiteral(data: IExtensionRangeOptions) {
    super.__fromLiteral(data);
  }

  toLiteral(): IExtensionRangeOptions {
    return super.__toLiteral();
  }
}

Registry.register(
  'google.protobuf.ExtensionRangeOptions',
  ExtensionRangeOptions,
);
