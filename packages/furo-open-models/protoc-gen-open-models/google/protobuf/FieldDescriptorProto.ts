// Code generated by furo protoc-gen-open-models. DO NOT EDIT.
// protoc-gen-open-models version: ????

import {
  BOOLEAN,
  ENUM,
  FieldNode,
  INT32,
  Registry,
  STRING,
} from '@furo/open-models/dist/index';
import { FieldDescriptorProtoLabel as GoogleProtobufFieldDescriptorProtoLabel } from './FieldDescriptorProto.Label';

import { FieldDescriptorProtoType as GoogleProtobufFieldDescriptorProtoType } from './FieldDescriptorProto.Type';

import {
  FieldOptions as GoogleProtobufFieldOptions,
  IFieldOptions as IGoogleProtobufFieldOptions,
  TFieldOptions as TGoogleProtobufFieldOptions,
} from './FieldOptions';

/**
 * @interface IFieldDescriptorProto
 *  Describes a field within a message.
 */
export interface IFieldDescriptorProto {
  name?: string;
  number?: number;
  label?: GoogleProtobufFieldDescriptorProtoLabel | string;
  /**
   *  If type_name is set, this need not be set.  If both this and type_name
   *  are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
   */
  type?: GoogleProtobufFieldDescriptorProtoType | string;
  /**
   *  For message and enum types, this is the name of the type.  If the name
   *  starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
   *  rules are used to find the type (i.e. first the nested types within this
   *  message are searched, then within the parent, on up to the root
   *  namespace).
   */
  typeName?: string;
  /**
   *  For extensions, this is the name of the type being extended.  It is
   *  resolved in the same manner as type_name.
   */
  extendee?: string;
  /**
   *  For numeric types, contains the original text representation of the value.
   *  For booleans, "true" or "false".
   *  For strings, contains the default text contents (not escaped in any way).
   *  For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
   */
  defaultValue?: string;
  /**
   *  If set, gives the index of a oneof in the containing type's oneof_decl
   *  list.  This field is a member of that oneof.
   */
  oneofIndex?: number;
  /**
   *  JSON name of this field. The value is set by protocol compiler. If the
   *  user has set a "json_name" option on this field, that option's value
   *  will be used. Otherwise, it's deduced from the field's name by converting
   *  it to camelCase.
   */
  jsonName?: string;
  options?: IGoogleProtobufFieldOptions;
  /**
   *  If true, this is a proto3 "optional". When a proto3 field is optional, it
   *  tracks presence regardless of field type.
   *
   *  When proto3_optional is true, this field must be belong to a oneof to
   *  signal to old proto3 clients that presence is tracked for this field. This
   *  oneof is known as a "synthetic" oneof, and this field must be its sole
   *  member (each proto3 optional field gets its own synthetic oneof). Synthetic
   *  oneofs exist in the descriptor only, and do not generate any API. Synthetic
   *  oneofs must be ordered after all "real" oneofs.
   *
   *  For message fields, proto3_optional doesn't create any semantic change,
   *  since non-repeated message fields always track presence. However it still
   *  indicates the semantic detail of whether the user wrote "optional" or not.
   *  This can be useful for round-tripping the .proto file. For consistency we
   *  give message fields a synthetic oneof also, even though it is not required
   *  to track presence. This is especially important because the parser can't
   *  tell if a field is a message or an enum, so it must always create a
   *  synthetic oneof.
   *
   *  Proto2 optional fields do not set this flag, because they already indicate
   *  optional with `LABEL_OPTIONAL`.
   */
  proto3Optional?: boolean;
}

/**
 * @interface TFieldDescriptorProto
 *  Describes a field within a message.
 */
export interface TFieldDescriptorProto {
  name?: string;
  number?: number;
  label?: GoogleProtobufFieldDescriptorProtoLabel | string;
  /**
   *  If type_name is set, this need not be set.  If both this and type_name
   *  are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
   */
  type?: GoogleProtobufFieldDescriptorProtoType | string;
  /**
   *  For message and enum types, this is the name of the type.  If the name
   *  starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
   *  rules are used to find the type (i.e. first the nested types within this
   *  message are searched, then within the parent, on up to the root
   *  namespace).
   */
  type_name?: string;
  /**
   *  For extensions, this is the name of the type being extended.  It is
   *  resolved in the same manner as type_name.
   */
  extendee?: string;
  /**
   *  For numeric types, contains the original text representation of the value.
   *  For booleans, "true" or "false".
   *  For strings, contains the default text contents (not escaped in any way).
   *  For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
   */
  default_value?: string;
  /**
   *  If set, gives the index of a oneof in the containing type's oneof_decl
   *  list.  This field is a member of that oneof.
   */
  oneof_index?: number;
  /**
   *  JSON name of this field. The value is set by protocol compiler. If the
   *  user has set a "json_name" option on this field, that option's value
   *  will be used. Otherwise, it's deduced from the field's name by converting
   *  it to camelCase.
   */
  json_name?: string;
  options?: TGoogleProtobufFieldOptions;
  /**
   *  If true, this is a proto3 "optional". When a proto3 field is optional, it
   *  tracks presence regardless of field type.
   *
   *  When proto3_optional is true, this field must be belong to a oneof to
   *  signal to old proto3 clients that presence is tracked for this field. This
   *  oneof is known as a "synthetic" oneof, and this field must be its sole
   *  member (each proto3 optional field gets its own synthetic oneof). Synthetic
   *  oneofs exist in the descriptor only, and do not generate any API. Synthetic
   *  oneofs must be ordered after all "real" oneofs.
   *
   *  For message fields, proto3_optional doesn't create any semantic change,
   *  since non-repeated message fields always track presence. However it still
   *  indicates the semantic detail of whether the user wrote "optional" or not.
   *  This can be useful for round-tripping the .proto file. For consistency we
   *  give message fields a synthetic oneof also, even though it is not required
   *  to track presence. This is especially important because the parser can't
   *  tell if a field is a message or an enum, so it must always create a
   *  synthetic oneof.
   *
   *  Proto2 optional fields do not set this flag, because they already indicate
   *  optional with `LABEL_OPTIONAL`.
   */
  proto3_optional?: boolean;
}

/**
 * FieldDescriptorProto
 *  Describes a field within a message.
 */
export class FieldDescriptorProto extends FieldNode {
  private _name: STRING;

  private _number: INT32;

  private _label: ENUM<GoogleProtobufFieldDescriptorProtoLabel>;

  //  If type_name is set, this need not be set.  If both this and type_name
  //  are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
  private _type: ENUM<GoogleProtobufFieldDescriptorProtoType>;

  //  For message and enum types, this is the name of the type.  If the name
  //  starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
  //  rules are used to find the type (i.e. first the nested types within this
  //  message are searched, then within the parent, on up to the root
  //  namespace).
  private _typeName: STRING;

  //  For extensions, this is the name of the type being extended.  It is
  //  resolved in the same manner as type_name.
  private _extendee: STRING;

  //  For numeric types, contains the original text representation of the value.
  //  For booleans, "true" or "false".
  //  For strings, contains the default text contents (not escaped in any way).
  //  For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
  private _defaultValue: STRING;

  //  If set, gives the index of a oneof in the containing type's oneof_decl
  //  list.  This field is a member of that oneof.
  private _oneofIndex: INT32;

  //  JSON name of this field. The value is set by protocol compiler. If the
  //  user has set a "json_name" option on this field, that option's value
  //  will be used. Otherwise, it's deduced from the field's name by converting
  //  it to camelCase.
  private _jsonName: STRING;

  private _options: GoogleProtobufFieldOptions;

  //  If true, this is a proto3 "optional". When a proto3 field is optional, it
  //  tracks presence regardless of field type.
  //
  //  When proto3_optional is true, this field must be belong to a oneof to
  //  signal to old proto3 clients that presence is tracked for this field. This
  //  oneof is known as a "synthetic" oneof, and this field must be its sole
  //  member (each proto3 optional field gets its own synthetic oneof). Synthetic
  //  oneofs exist in the descriptor only, and do not generate any API. Synthetic
  //  oneofs must be ordered after all "real" oneofs.
  //
  //  For message fields, proto3_optional doesn't create any semantic change,
  //  since non-repeated message fields always track presence. However it still
  //  indicates the semantic detail of whether the user wrote "optional" or not.
  //  This can be useful for round-tripping the .proto file. For consistency we
  //  give message fields a synthetic oneof also, even though it is not required
  //  to track presence. This is especially important because the parser can't
  //  tell if a field is a message or an enum, so it must always create a
  //  synthetic oneof.
  //
  //  Proto2 optional fields do not set this flag, because they already indicate
  //  optional with `LABEL_OPTIONAL`.
  private _proto3Optional: BOOLEAN;

  public __defaultValues: IFieldDescriptorProto;

  constructor(
    initData?: IFieldDescriptorProto,
    parent?: FieldNode,
    parentAttributeName?: string,
  ) {
    super(undefined, parent, parentAttributeName);
    this.__meta.typeName = 'google.protobuf.FieldDescriptorProto';

    this.__meta.nodeFields = [
      {
        fieldName: 'name',
        protoName: 'name',
        FieldConstructor: STRING,
        constraints: {},
      },
      {
        fieldName: 'number',
        protoName: 'number',
        FieldConstructor: INT32,
        constraints: {},
      },
      {
        fieldName: 'label',
        protoName: 'label',
        FieldConstructor: ENUM<GoogleProtobufFieldDescriptorProtoLabel>,
        constraints: {},
      },
      {
        fieldName: 'type',
        protoName: 'type',
        FieldConstructor: ENUM<GoogleProtobufFieldDescriptorProtoType>,
        constraints: {},
      },
      {
        fieldName: 'typeName',
        protoName: 'type_name',
        FieldConstructor: STRING,
        constraints: {},
      },
      {
        fieldName: 'extendee',
        protoName: 'extendee',
        FieldConstructor: STRING,
        constraints: {},
      },
      {
        fieldName: 'defaultValue',
        protoName: 'default_value',
        FieldConstructor: STRING,
        constraints: {},
      },
      {
        fieldName: 'oneofIndex',
        protoName: 'oneof_index',
        FieldConstructor: INT32,
        constraints: {},
      },
      {
        fieldName: 'jsonName',
        protoName: 'json_name',
        FieldConstructor: STRING,
        constraints: {},
      },
      {
        fieldName: 'options',
        protoName: 'options',
        FieldConstructor: GoogleProtobufFieldOptions,
        constraints: {},
      },
      {
        fieldName: 'proto3Optional',
        protoName: 'proto3_optional',
        FieldConstructor: BOOLEAN,
        constraints: {},
      },
    ];

    // Initialize the fields
    this._name = new STRING(undefined, this, 'name');

    this._number = new INT32(undefined, this, 'number');

    this._label = new ENUM<GoogleProtobufFieldDescriptorProtoLabel>(
      undefined,
      GoogleProtobufFieldDescriptorProtoLabel,
      GoogleProtobufFieldDescriptorProtoLabel.LABEL_OPTIONAL,
      this,
      'label',
    );

    //  If type_name is set, this need not be set.  If both this and type_name
    //  are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
    this._type = new ENUM<GoogleProtobufFieldDescriptorProtoType>(
      undefined,
      GoogleProtobufFieldDescriptorProtoType,
      GoogleProtobufFieldDescriptorProtoType.TYPE_DOUBLE,
      this,
      'type',
    );

    //  For message and enum types, this is the name of the type.  If the name
    //  starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
    //  rules are used to find the type (i.e. first the nested types within this
    //  message are searched, then within the parent, on up to the root
    //  namespace).
    this._typeName = new STRING(undefined, this, 'typeName');

    //  For extensions, this is the name of the type being extended.  It is
    //  resolved in the same manner as type_name.
    this._extendee = new STRING(undefined, this, 'extendee');

    //  For numeric types, contains the original text representation of the value.
    //  For booleans, "true" or "false".
    //  For strings, contains the default text contents (not escaped in any way).
    //  For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
    this._defaultValue = new STRING(undefined, this, 'defaultValue');

    //  If set, gives the index of a oneof in the containing type's oneof_decl
    //  list.  This field is a member of that oneof.
    this._oneofIndex = new INT32(undefined, this, 'oneofIndex');

    //  JSON name of this field. The value is set by protocol compiler. If the
    //  user has set a "json_name" option on this field, that option's value
    //  will be used. Otherwise, it's deduced from the field's name by converting
    //  it to camelCase.
    this._jsonName = new STRING(undefined, this, 'jsonName');

    this._options = new GoogleProtobufFieldOptions(undefined, this, 'options');

    //  If true, this is a proto3 "optional". When a proto3 field is optional, it
    //  tracks presence regardless of field type.
    //
    //  When proto3_optional is true, this field must be belong to a oneof to
    //  signal to old proto3 clients that presence is tracked for this field. This
    //  oneof is known as a "synthetic" oneof, and this field must be its sole
    //  member (each proto3 optional field gets its own synthetic oneof). Synthetic
    //  oneofs exist in the descriptor only, and do not generate any API. Synthetic
    //  oneofs must be ordered after all "real" oneofs.
    //
    //  For message fields, proto3_optional doesn't create any semantic change,
    //  since non-repeated message fields always track presence. However it still
    //  indicates the semantic detail of whether the user wrote "optional" or not.
    //  This can be useful for round-tripping the .proto file. For consistency we
    //  give message fields a synthetic oneof also, even though it is not required
    //  to track presence. This is especially important because the parser can't
    //  tell if a field is a message or an enum, so it must always create a
    //  synthetic oneof.
    //
    //  Proto2 optional fields do not set this flag, because they already indicate
    //  optional with `LABEL_OPTIONAL`.
    this._proto3Optional = new BOOLEAN(undefined, this, 'proto3Optional');

    // Set required fields
    [].forEach(fieldName => {
      (
        this[fieldName as keyof FieldDescriptorProto] as FieldNode
      ).__meta.required = true;
    });

    // Default values from openAPI annotations
    this.__defaultValues = {};

    // Initialize the fields with init data
    if (initData !== undefined) {
      this.__fromLiteral({ ...this.__defaultValues, ...initData });
    } else {
      this.__fromLiteral(this.__defaultValues);
    }

    // Set readonly fields after the init, so child nodes are readonly too
    [].forEach(fieldName => {
      (this[fieldName as keyof FieldDescriptorProto] as FieldNode).__readonly =
        true;
    });

    this.__meta.isPristine = true;
  }

  public get name(): STRING {
    return this._name;
  }

  public set name(v: string) {
    this.__PrimitivesSetter(this._name, v);
  }

  public get number(): INT32 {
    return this._number;
  }

  public set number(v: number) {
    this.__PrimitivesSetter(this._number, v);
  }

  public get label(): ENUM<GoogleProtobufFieldDescriptorProtoLabel> {
    return this._label;
  }

  public set label(v: GoogleProtobufFieldDescriptorProtoLabel) {
    this.__TypeSetter(this._label, v);
  }

  //  If type_name is set, this need not be set.  If both this and type_name
  //  are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
  public get type(): ENUM<GoogleProtobufFieldDescriptorProtoType> {
    return this._type;
  }

  public set type(v: GoogleProtobufFieldDescriptorProtoType) {
    this.__TypeSetter(this._type, v);
  }

  //  For message and enum types, this is the name of the type.  If the name
  //  starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
  //  rules are used to find the type (i.e. first the nested types within this
  //  message are searched, then within the parent, on up to the root
  //  namespace).
  public get typeName(): STRING {
    return this._typeName;
  }

  public set typeName(v: string) {
    this.__PrimitivesSetter(this._typeName, v);
  }

  //  For extensions, this is the name of the type being extended.  It is
  //  resolved in the same manner as type_name.
  public get extendee(): STRING {
    return this._extendee;
  }

  public set extendee(v: string) {
    this.__PrimitivesSetter(this._extendee, v);
  }

  //  For numeric types, contains the original text representation of the value.
  //  For booleans, "true" or "false".
  //  For strings, contains the default text contents (not escaped in any way).
  //  For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
  public get defaultValue(): STRING {
    return this._defaultValue;
  }

  public set defaultValue(v: string) {
    this.__PrimitivesSetter(this._defaultValue, v);
  }

  //  If set, gives the index of a oneof in the containing type's oneof_decl
  //  list.  This field is a member of that oneof.
  public get oneofIndex(): INT32 {
    return this._oneofIndex;
  }

  public set oneofIndex(v: number) {
    this.__PrimitivesSetter(this._oneofIndex, v);
  }

  //  JSON name of this field. The value is set by protocol compiler. If the
  //  user has set a "json_name" option on this field, that option's value
  //  will be used. Otherwise, it's deduced from the field's name by converting
  //  it to camelCase.
  public get jsonName(): STRING {
    return this._jsonName;
  }

  public set jsonName(v: string) {
    this.__PrimitivesSetter(this._jsonName, v);
  }

  public get options(): GoogleProtobufFieldOptions {
    return this._options;
  }

  public set options(v: IGoogleProtobufFieldOptions) {
    this.__TypeSetter(this._options, v);
  }

  //  If true, this is a proto3 "optional". When a proto3 field is optional, it
  //  tracks presence regardless of field type.
  //
  //  When proto3_optional is true, this field must be belong to a oneof to
  //  signal to old proto3 clients that presence is tracked for this field. This
  //  oneof is known as a "synthetic" oneof, and this field must be its sole
  //  member (each proto3 optional field gets its own synthetic oneof). Synthetic
  //  oneofs exist in the descriptor only, and do not generate any API. Synthetic
  //  oneofs must be ordered after all "real" oneofs.
  //
  //  For message fields, proto3_optional doesn't create any semantic change,
  //  since non-repeated message fields always track presence. However it still
  //  indicates the semantic detail of whether the user wrote "optional" or not.
  //  This can be useful for round-tripping the .proto file. For consistency we
  //  give message fields a synthetic oneof also, even though it is not required
  //  to track presence. This is especially important because the parser can't
  //  tell if a field is a message or an enum, so it must always create a
  //  synthetic oneof.
  //
  //  Proto2 optional fields do not set this flag, because they already indicate
  //  optional with `LABEL_OPTIONAL`.
  public get proto3Optional(): BOOLEAN {
    return this._proto3Optional;
  }

  public set proto3Optional(v: boolean) {
    this.__PrimitivesSetter(this._proto3Optional, v);
  }

  fromLiteral(data: IFieldDescriptorProto) {
    super.__fromLiteral(data);
  }

  toLiteral(): IFieldDescriptorProto {
    return super.__toLiteral();
  }
}

Registry.register('google.protobuf.FieldDescriptorProto', FieldDescriptorProto);
