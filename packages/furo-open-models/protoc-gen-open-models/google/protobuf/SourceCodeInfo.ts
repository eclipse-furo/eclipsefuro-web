// Code generated by furo protoc-gen-open-models. DO NOT EDIT.
// protoc-gen-open-models version: ????

import { ARRAY, FieldNode, Registry } from '@furo/open-models/dist/index';
import {
  ISourceCodeInfoLocation as IGoogleProtobufSourceCodeInfoLocation,
  SourceCodeInfoLocation as GoogleProtobufSourceCodeInfoLocation,
  TSourceCodeInfoLocation as TGoogleProtobufSourceCodeInfoLocation,
} from './SourceCodeInfo.Location';

/**
 * @interface ISourceCodeInfo
 *  Encapsulates information about the original source file from which a
 *  FileDescriptorProto was generated.
 */
export interface ISourceCodeInfo {
  /**
   *  A Location identifies a piece of source code in a .proto file which
   *  corresponds to a particular definition.  This information is intended
   *  to be useful to IDEs, code indexers, documentation generators, and similar
   *  tools.
   *
   *  For example, say we have a file like:
   *    message Foo {
   *      optional string foo = 1;
   *    }
   *  Let's look at just the field definition:
   *    optional string foo = 1;
   *    ^       ^^     ^^  ^  ^^^
   *    a       bc     de  f  ghi
   *  We have the following locations:
   *    span   path               represents
   *    [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
   *    [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
   *    [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
   *    [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
   *    [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
   *
   *  Notes:
   *  - A location may refer to a repeated field itself (i.e. not to any
   *    particular index within it).  This is used whenever a set of elements are
   *    logically enclosed in a single code segment.  For example, an entire
   *    extend block (possibly containing multiple extension definitions) will
   *    have an outer location whose path refers to the "extensions" repeated
   *    field without an index.
   *  - Multiple locations may have the same path.  This happens when a single
   *    logical declaration is spread out across multiple places.  The most
   *    obvious example is the "extend" block again -- there may be multiple
   *    extend blocks in the same scope, each of which will have the same path.
   *  - A location's span is not always a subset of its parent's span.  For
   *    example, the "extendee" of an extension declaration appears at the
   *    beginning of the "extend" block and is shared by all extensions within
   *    the block.
   *  - Just because a location's span is a subset of some other location's span
   *    does not mean that it is a descendant.  For example, a "group" defines
   *    both a type and a field in a single declaration.  Thus, the locations
   *    corresponding to the type and field and their components will overlap.
   *  - Code which tries to interpret locations should probably be designed to
   *    ignore those that it doesn't understand, as more types of locations could
   *    be recorded in the future.
   */
  location?: IGoogleProtobufSourceCodeInfoLocation[];
}

/**
 * @interface TSourceCodeInfo
 *  Encapsulates information about the original source file from which a
 *  FileDescriptorProto was generated.
 */
export interface TSourceCodeInfo {
  /**
   *  A Location identifies a piece of source code in a .proto file which
   *  corresponds to a particular definition.  This information is intended
   *  to be useful to IDEs, code indexers, documentation generators, and similar
   *  tools.
   *
   *  For example, say we have a file like:
   *    message Foo {
   *      optional string foo = 1;
   *    }
   *  Let's look at just the field definition:
   *    optional string foo = 1;
   *    ^       ^^     ^^  ^  ^^^
   *    a       bc     de  f  ghi
   *  We have the following locations:
   *    span   path               represents
   *    [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
   *    [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
   *    [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
   *    [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
   *    [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
   *
   *  Notes:
   *  - A location may refer to a repeated field itself (i.e. not to any
   *    particular index within it).  This is used whenever a set of elements are
   *    logically enclosed in a single code segment.  For example, an entire
   *    extend block (possibly containing multiple extension definitions) will
   *    have an outer location whose path refers to the "extensions" repeated
   *    field without an index.
   *  - Multiple locations may have the same path.  This happens when a single
   *    logical declaration is spread out across multiple places.  The most
   *    obvious example is the "extend" block again -- there may be multiple
   *    extend blocks in the same scope, each of which will have the same path.
   *  - A location's span is not always a subset of its parent's span.  For
   *    example, the "extendee" of an extension declaration appears at the
   *    beginning of the "extend" block and is shared by all extensions within
   *    the block.
   *  - Just because a location's span is a subset of some other location's span
   *    does not mean that it is a descendant.  For example, a "group" defines
   *    both a type and a field in a single declaration.  Thus, the locations
   *    corresponding to the type and field and their components will overlap.
   *  - Code which tries to interpret locations should probably be designed to
   *    ignore those that it doesn't understand, as more types of locations could
   *    be recorded in the future.
   */
  location?: TGoogleProtobufSourceCodeInfoLocation[];
}

/**
 * SourceCodeInfo
 *  Encapsulates information about the original source file from which a
 *  FileDescriptorProto was generated.
 */
export class SourceCodeInfo extends FieldNode {
  //  A Location identifies a piece of source code in a .proto file which
  //  corresponds to a particular definition.  This information is intended
  //  to be useful to IDEs, code indexers, documentation generators, and similar
  //  tools.
  //
  //  For example, say we have a file like:
  //    message Foo {
  //      optional string foo = 1;
  //    }
  //  Let's look at just the field definition:
  //    optional string foo = 1;
  //    ^       ^^     ^^  ^  ^^^
  //    a       bc     de  f  ghi
  //  We have the following locations:
  //    span   path               represents
  //    [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
  //    [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
  //    [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
  //    [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
  //    [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
  //
  //  Notes:
  //  - A location may refer to a repeated field itself (i.e. not to any
  //    particular index within it).  This is used whenever a set of elements are
  //    logically enclosed in a single code segment.  For example, an entire
  //    extend block (possibly containing multiple extension definitions) will
  //    have an outer location whose path refers to the "extensions" repeated
  //    field without an index.
  //  - Multiple locations may have the same path.  This happens when a single
  //    logical declaration is spread out across multiple places.  The most
  //    obvious example is the "extend" block again -- there may be multiple
  //    extend blocks in the same scope, each of which will have the same path.
  //  - A location's span is not always a subset of its parent's span.  For
  //    example, the "extendee" of an extension declaration appears at the
  //    beginning of the "extend" block and is shared by all extensions within
  //    the block.
  //  - Just because a location's span is a subset of some other location's span
  //    does not mean that it is a descendant.  For example, a "group" defines
  //    both a type and a field in a single declaration.  Thus, the locations
  //    corresponding to the type and field and their components will overlap.
  //  - Code which tries to interpret locations should probably be designed to
  //    ignore those that it doesn't understand, as more types of locations could
  //    be recorded in the future.
  private _location: ARRAY<
    GoogleProtobufSourceCodeInfoLocation,
    IGoogleProtobufSourceCodeInfoLocation
  >;

  public __defaultValues: ISourceCodeInfo;

  constructor(
    initData?: ISourceCodeInfo,
    parent?: FieldNode,
    parentAttributeName?: string,
  ) {
    super(undefined, parent, parentAttributeName);
    this.__meta.typeName = 'google.protobuf.SourceCodeInfo';

    this.__meta.nodeFields = [
      {
        fieldName: 'location',
        protoName: 'location',
        FieldConstructor: GoogleProtobufSourceCodeInfoLocation,
        constraints: {},
      },
    ];

    // Initialize the fields
    //  A Location identifies a piece of source code in a .proto file which
    //  corresponds to a particular definition.  This information is intended
    //  to be useful to IDEs, code indexers, documentation generators, and similar
    //  tools.
    //
    //  For example, say we have a file like:
    //    message Foo {
    //      optional string foo = 1;
    //    }
    //  Let's look at just the field definition:
    //    optional string foo = 1;
    //    ^       ^^     ^^  ^  ^^^
    //    a       bc     de  f  ghi
    //  We have the following locations:
    //    span   path               represents
    //    [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
    //    [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
    //    [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
    //    [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
    //    [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
    //
    //  Notes:
    //  - A location may refer to a repeated field itself (i.e. not to any
    //    particular index within it).  This is used whenever a set of elements are
    //    logically enclosed in a single code segment.  For example, an entire
    //    extend block (possibly containing multiple extension definitions) will
    //    have an outer location whose path refers to the "extensions" repeated
    //    field without an index.
    //  - Multiple locations may have the same path.  This happens when a single
    //    logical declaration is spread out across multiple places.  The most
    //    obvious example is the "extend" block again -- there may be multiple
    //    extend blocks in the same scope, each of which will have the same path.
    //  - A location's span is not always a subset of its parent's span.  For
    //    example, the "extendee" of an extension declaration appears at the
    //    beginning of the "extend" block and is shared by all extensions within
    //    the block.
    //  - Just because a location's span is a subset of some other location's span
    //    does not mean that it is a descendant.  For example, a "group" defines
    //    both a type and a field in a single declaration.  Thus, the locations
    //    corresponding to the type and field and their components will overlap.
    //  - Code which tries to interpret locations should probably be designed to
    //    ignore those that it doesn't understand, as more types of locations could
    //    be recorded in the future.
    this._location = new ARRAY<
      GoogleProtobufSourceCodeInfoLocation,
      IGoogleProtobufSourceCodeInfoLocation
    >(undefined, this, 'location');

    // Set required fields
    [].forEach(fieldName => {
      (this[fieldName as keyof SourceCodeInfo] as FieldNode).__meta.required =
        true;
    });

    // Default values from openAPI annotations
    this.__defaultValues = {};

    // Initialize the fields with init data
    if (initData !== undefined) {
      this.__fromLiteral({ ...this.__defaultValues, ...initData });
    } else {
      this.__fromLiteral(this.__defaultValues);
    }

    // Set readonly fields after the init, so child nodes are readonly too
    [].forEach(fieldName => {
      (this[fieldName as keyof SourceCodeInfo] as FieldNode).__readonly = true;
    });

    this.__meta.isPristine = true;
  }

  //  A Location identifies a piece of source code in a .proto file which
  //  corresponds to a particular definition.  This information is intended
  //  to be useful to IDEs, code indexers, documentation generators, and similar
  //  tools.
  //
  //  For example, say we have a file like:
  //    message Foo {
  //      optional string foo = 1;
  //    }
  //  Let's look at just the field definition:
  //    optional string foo = 1;
  //    ^       ^^     ^^  ^  ^^^
  //    a       bc     de  f  ghi
  //  We have the following locations:
  //    span   path               represents
  //    [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
  //    [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
  //    [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
  //    [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
  //    [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
  //
  //  Notes:
  //  - A location may refer to a repeated field itself (i.e. not to any
  //    particular index within it).  This is used whenever a set of elements are
  //    logically enclosed in a single code segment.  For example, an entire
  //    extend block (possibly containing multiple extension definitions) will
  //    have an outer location whose path refers to the "extensions" repeated
  //    field without an index.
  //  - Multiple locations may have the same path.  This happens when a single
  //    logical declaration is spread out across multiple places.  The most
  //    obvious example is the "extend" block again -- there may be multiple
  //    extend blocks in the same scope, each of which will have the same path.
  //  - A location's span is not always a subset of its parent's span.  For
  //    example, the "extendee" of an extension declaration appears at the
  //    beginning of the "extend" block and is shared by all extensions within
  //    the block.
  //  - Just because a location's span is a subset of some other location's span
  //    does not mean that it is a descendant.  For example, a "group" defines
  //    both a type and a field in a single declaration.  Thus, the locations
  //    corresponding to the type and field and their components will overlap.
  //  - Code which tries to interpret locations should probably be designed to
  //    ignore those that it doesn't understand, as more types of locations could
  //    be recorded in the future.
  public get location(): ARRAY<
    GoogleProtobufSourceCodeInfoLocation,
    IGoogleProtobufSourceCodeInfoLocation
  > {
    return this._location;
  }

  public set location(v: IGoogleProtobufSourceCodeInfoLocation[]) {
    this.__TypeSetter(this._location, v);
  }

  fromLiteral(data: ISourceCodeInfo) {
    super.__fromLiteral(data);
  }

  toLiteral(): ISourceCodeInfo {
    return super.__toLiteral();
  }
}

Registry.register('google.protobuf.SourceCodeInfo', SourceCodeInfo);
