// Code generated by furo protoc-gen-open-models. DO NOT EDIT.
// protoc-gen-open-models version: ????

import {
  ARRAY,
  BYTES,
  DOUBLE,
  FieldNode,
  INT64,
  Registry,
  STRING,
  UINT64,
} from '@furo/open-models/dist/index';
import {
  IUninterpretedOptionNamePart as IGoogleProtobufUninterpretedOptionNamePart,
  TUninterpretedOptionNamePart as TGoogleProtobufUninterpretedOptionNamePart,
  UninterpretedOptionNamePart as GoogleProtobufUninterpretedOptionNamePart,
} from './UninterpretedOption.NamePart';

/**
 * @interface IUninterpretedOption
 *  A message representing a option the parser does not recognize. This only
 *  appears in options protos created by the compiler::Parser class.
 *  DescriptorPool resolves these when building Descriptor objects. Therefore,
 *  options protos in descriptor objects (e.g. returned by Descriptor::options(),
 *  or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
 *  in them.
 */
export interface IUninterpretedOption {
  name?: IGoogleProtobufUninterpretedOptionNamePart[];
  /**
   *  The value of the uninterpreted option, in whatever type the tokenizer
   *  identified it as during parsing. Exactly one of these should be set.
   */
  identifierValue?: string;
  positiveIntValue?: string;
  negativeIntValue?: string;
  doubleValue?: number;
  stringValue?: string;
  aggregateValue?: string;
}

/**
 * @interface TUninterpretedOption
 *  A message representing a option the parser does not recognize. This only
 *  appears in options protos created by the compiler::Parser class.
 *  DescriptorPool resolves these when building Descriptor objects. Therefore,
 *  options protos in descriptor objects (e.g. returned by Descriptor::options(),
 *  or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
 *  in them.
 */
export interface TUninterpretedOption {
  name?: TGoogleProtobufUninterpretedOptionNamePart[];
  /**
   *  The value of the uninterpreted option, in whatever type the tokenizer
   *  identified it as during parsing. Exactly one of these should be set.
   */
  identifier_value?: string;
  positive_int_value?: string;
  negative_int_value?: string;
  double_value?: number;
  string_value?: string;
  aggregate_value?: string;
}

/**
 * UninterpretedOption
 *  A message representing a option the parser does not recognize. This only
 *  appears in options protos created by the compiler::Parser class.
 *  DescriptorPool resolves these when building Descriptor objects. Therefore,
 *  options protos in descriptor objects (e.g. returned by Descriptor::options(),
 *  or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
 *  in them.
 */
export class UninterpretedOption extends FieldNode {
  private _name: ARRAY<
    GoogleProtobufUninterpretedOptionNamePart,
    IGoogleProtobufUninterpretedOptionNamePart
  >;

  //  The value of the uninterpreted option, in whatever type the tokenizer
  //  identified it as during parsing. Exactly one of these should be set.
  private _identifierValue: STRING;

  private _positiveIntValue: UINT64;

  private _negativeIntValue: INT64;

  private _doubleValue: DOUBLE;

  private _stringValue: BYTES;

  private _aggregateValue: STRING;

  public __defaultValues: IUninterpretedOption;

  constructor(
    initData?: IUninterpretedOption,
    parent?: FieldNode,
    parentAttributeName?: string,
  ) {
    super(undefined, parent, parentAttributeName);
    this.__meta.typeName = 'google.protobuf.UninterpretedOption';

    this.__meta.nodeFields = [
      {
        fieldName: 'name',
        protoName: 'name',
        FieldConstructor: GoogleProtobufUninterpretedOptionNamePart,
        constraints: {},
      },
      {
        fieldName: 'identifierValue',
        protoName: 'identifier_value',
        FieldConstructor: STRING,
        constraints: {},
      },
      {
        fieldName: 'positiveIntValue',
        protoName: 'positive_int_value',
        FieldConstructor: UINT64,
        constraints: {},
      },
      {
        fieldName: 'negativeIntValue',
        protoName: 'negative_int_value',
        FieldConstructor: INT64,
        constraints: {},
      },
      {
        fieldName: 'doubleValue',
        protoName: 'double_value',
        FieldConstructor: DOUBLE,
        constraints: {},
      },
      {
        fieldName: 'stringValue',
        protoName: 'string_value',
        FieldConstructor: BYTES,
        constraints: {},
      },
      {
        fieldName: 'aggregateValue',
        protoName: 'aggregate_value',
        FieldConstructor: STRING,
        constraints: {},
      },
    ];

    // Initialize the fields
    this._name = new ARRAY<
      GoogleProtobufUninterpretedOptionNamePart,
      IGoogleProtobufUninterpretedOptionNamePart
    >(undefined, this, 'name');

    //  The value of the uninterpreted option, in whatever type the tokenizer
    //  identified it as during parsing. Exactly one of these should be set.
    this._identifierValue = new STRING(undefined, this, 'identifierValue');

    this._positiveIntValue = new UINT64(undefined, this, 'positiveIntValue');

    this._negativeIntValue = new INT64(undefined, this, 'negativeIntValue');

    this._doubleValue = new DOUBLE(undefined, this, 'doubleValue');

    this._stringValue = new BYTES(undefined, this, 'stringValue');

    this._aggregateValue = new STRING(undefined, this, 'aggregateValue');

    // Set required fields
    [].forEach(fieldName => {
      (
        this[fieldName as keyof UninterpretedOption] as FieldNode
      ).__meta.required = true;
    });

    // Default values from openAPI annotations
    this.__defaultValues = {};

    // Initialize the fields with init data
    if (initData !== undefined) {
      this.__fromLiteral({ ...this.__defaultValues, ...initData });
    } else {
      this.__fromLiteral(this.__defaultValues);
    }

    // Set readonly fields after the init, so child nodes are readonly too
    [].forEach(fieldName => {
      (this[fieldName as keyof UninterpretedOption] as FieldNode).__readonly =
        true;
    });

    this.__meta.isPristine = true;
  }

  public get name(): ARRAY<
    GoogleProtobufUninterpretedOptionNamePart,
    IGoogleProtobufUninterpretedOptionNamePart
  > {
    return this._name;
  }

  public set name(v: IGoogleProtobufUninterpretedOptionNamePart[]) {
    this.__TypeSetter(this._name, v);
  }

  //  The value of the uninterpreted option, in whatever type the tokenizer
  //  identified it as during parsing. Exactly one of these should be set.
  public get identifierValue(): STRING {
    return this._identifierValue;
  }

  public set identifierValue(v: string) {
    this.__PrimitivesSetter(this._identifierValue, v);
  }

  public get positiveIntValue(): UINT64 {
    return this._positiveIntValue;
  }

  public set positiveIntValue(v: bigint) {
    this.__PrimitivesSetter(this._positiveIntValue, v);
  }

  public get negativeIntValue(): INT64 {
    return this._negativeIntValue;
  }

  public set negativeIntValue(v: bigint) {
    this.__PrimitivesSetter(this._negativeIntValue, v);
  }

  public get doubleValue(): DOUBLE {
    return this._doubleValue;
  }

  public set doubleValue(v: number) {
    this.__PrimitivesSetter(this._doubleValue, v);
  }

  public get stringValue(): BYTES {
    return this._stringValue;
  }

  public set stringValue(v: string) {
    this.__PrimitivesSetter(this._stringValue, v);
  }

  public get aggregateValue(): STRING {
    return this._aggregateValue;
  }

  public set aggregateValue(v: string) {
    this.__PrimitivesSetter(this._aggregateValue, v);
  }

  fromLiteral(data: IUninterpretedOption) {
    super.__fromLiteral(data);
  }

  toLiteral(): IUninterpretedOption {
    return super.__toLiteral();
  }
}

Registry.register('google.protobuf.UninterpretedOption', UninterpretedOption);
