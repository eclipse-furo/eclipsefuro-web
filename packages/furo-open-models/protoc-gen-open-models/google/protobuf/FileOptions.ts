// Code generated by furo protoc-gen-open-models. DO NOT EDIT.
// protoc-gen-open-models version: ????

import {
  ARRAY,
  BOOLEAN,
  ENUM,
  FieldNode,
  Registry,
  STRING,
} from '@furo/open-models/dist/index';
import {
  FeatureSet as GoogleProtobufFeatureSet,
  IFeatureSet as IGoogleProtobufFeatureSet,
  TFeatureSet as TGoogleProtobufFeatureSet,
} from './FeatureSet';

import { FileOptionsOptimizeMode as GoogleProtobufFileOptionsOptimizeMode } from './FileOptions.OptimizeMode';

import {
  IUninterpretedOption as IGoogleProtobufUninterpretedOption,
  TUninterpretedOption as TGoogleProtobufUninterpretedOption,
  UninterpretedOption as GoogleProtobufUninterpretedOption,
} from './UninterpretedOption';

/**
 * @interface IFileOptions
 */
export interface IFileOptions {
  /**
   *  Sets the Java package where classes generated from this .proto will be
   *  placed.  By default, the proto package is used, but this is often
   *  inappropriate because proto packages do not normally start with backwards
   *  domain names.
   */
  javaPackage?: string;
  /**
   *  Controls the name of the wrapper Java class generated for the .proto file.
   *  That class will always contain the .proto file's getDescriptor() method as
   *  well as any top-level extensions defined in the .proto file.
   *  If java_multiple_files is disabled, then all the other classes from the
   *  .proto file will be nested inside the single wrapper outer class.
   */
  javaOuterClassname?: string;
  /**
   *  If enabled, then the Java code generator will generate a separate .java
   *  file for each top-level message, enum, and service defined in the .proto
   *  file.  Thus, these types will *not* be nested inside the wrapper class
   *  named by java_outer_classname.  However, the wrapper class will still be
   *  generated to contain the file's getDescriptor() method as well as any
   *  top-level extensions defined in the file.
   */
  javaMultipleFiles?: boolean;
  /**
   *  This option does nothing.
   */
  javaGenerateEqualsAndHash?: boolean;
  /**
   *  If set true, then the Java2 code generator will generate code that
   *  throws an exception whenever an attempt is made to assign a non-UTF-8
   *  byte sequence to a string field.
   *  Message reflection will do the same.
   *  However, an extension field still accepts non-UTF-8 byte sequences.
   *  This option has no effect on when used with the lite runtime.
   */
  javaStringCheckUtf8?: boolean;
  optimizeFor?: GoogleProtobufFileOptionsOptimizeMode | string;
  /**
   *  Sets the Go package where structs generated from this .proto will be
   *  placed. If omitted, the Go package will be derived from the following:
   *    - The basename of the package import path, if provided.
   *    - Otherwise, the package statement in the .proto file, if present.
   *    - Otherwise, the basename of the .proto file, without extension.
   */
  goPackage?: string;
  /**
   *  Should generic services be generated in each language?  "Generic" services
   *  are not specific to any particular RPC system.  They are generated by the
   *  main code generators in each language (without additional plugins).
   *  Generic services were the only kind of service generation supported by
   *  early versions of google.protobuf.
   *
   *  Generic services are now considered deprecated in favor of using plugins
   *  that generate code specific to your particular RPC system.  Therefore,
   *  these default to false.  Old code which depends on generic services should
   *  explicitly set them to true.
   */
  ccGenericServices?: boolean;
  javaGenericServices?: boolean;
  pyGenericServices?: boolean;
  phpGenericServices?: boolean;
  /**
   *  Is this file deprecated?
   *  Depending on the target platform, this can emit Deprecated annotations
   *  for everything in the file, or it will be completely ignored; in the very
   *  least, this is a formalization for deprecating files.
   */
  deprecated?: boolean;
  /**
   *  Enables the use of arenas for the proto messages in this file. This applies
   *  only to generated classes for C++.
   */
  ccEnableArenas?: boolean;
  /**
   *  Sets the objective c class prefix which is prepended to all objective c
   *  generated classes from this .proto. There is no default.
   */
  objcClassPrefix?: string;
  /**
   *  Namespace for generated classes; defaults to the package.
   */
  csharpNamespace?: string;
  /**
   *  By default Swift generators will take the proto package and CamelCase it
   *  replacing '.' with underscore and use that to prefix the types/symbols
   *  defined. When this options is provided, they will use this value instead
   *  to prefix the types/symbols defined.
   */
  swiftPrefix?: string;
  /**
   *  Sets the php class prefix which is prepended to all php generated classes
   *  from this .proto. Default is empty.
   */
  phpClassPrefix?: string;
  /**
   *  Use this option to change the namespace of php generated classes. Default
   *  is empty. When this option is empty, the package name will be used for
   *  determining the namespace.
   */
  phpNamespace?: string;
  /**
   *  Use this option to change the namespace of php generated metadata classes.
   *  Default is empty. When this option is empty, the proto file name will be
   *  used for determining the namespace.
   */
  phpMetadataNamespace?: string;
  /**
   *  Use this option to change the package of ruby generated classes. Default
   *  is empty. When this option is not set, the package name will be used for
   *  determining the ruby package.
   */
  rubyPackage?: string;
  /**
   *  Any features defined in the specific edition.
   */
  features?: IGoogleProtobufFeatureSet;
  /**
   *  The parser stores options it doesn't recognize here.
   *  See the documentation for the "Options" section above.
   */
  uninterpretedOption?: IGoogleProtobufUninterpretedOption[];
}

/**
 * @interface TFileOptions
 */
export interface TFileOptions {
  /**
   *  Sets the Java package where classes generated from this .proto will be
   *  placed.  By default, the proto package is used, but this is often
   *  inappropriate because proto packages do not normally start with backwards
   *  domain names.
   */
  java_package?: string;
  /**
   *  Controls the name of the wrapper Java class generated for the .proto file.
   *  That class will always contain the .proto file's getDescriptor() method as
   *  well as any top-level extensions defined in the .proto file.
   *  If java_multiple_files is disabled, then all the other classes from the
   *  .proto file will be nested inside the single wrapper outer class.
   */
  java_outer_classname?: string;
  /**
   *  If enabled, then the Java code generator will generate a separate .java
   *  file for each top-level message, enum, and service defined in the .proto
   *  file.  Thus, these types will *not* be nested inside the wrapper class
   *  named by java_outer_classname.  However, the wrapper class will still be
   *  generated to contain the file's getDescriptor() method as well as any
   *  top-level extensions defined in the file.
   */
  java_multiple_files?: boolean;
  /**
   *  This option does nothing.
   */
  java_generate_equals_and_hash?: boolean;
  /**
   *  If set true, then the Java2 code generator will generate code that
   *  throws an exception whenever an attempt is made to assign a non-UTF-8
   *  byte sequence to a string field.
   *  Message reflection will do the same.
   *  However, an extension field still accepts non-UTF-8 byte sequences.
   *  This option has no effect on when used with the lite runtime.
   */
  java_string_check_utf8?: boolean;
  optimize_for?: GoogleProtobufFileOptionsOptimizeMode | string;
  /**
   *  Sets the Go package where structs generated from this .proto will be
   *  placed. If omitted, the Go package will be derived from the following:
   *    - The basename of the package import path, if provided.
   *    - Otherwise, the package statement in the .proto file, if present.
   *    - Otherwise, the basename of the .proto file, without extension.
   */
  go_package?: string;
  /**
   *  Should generic services be generated in each language?  "Generic" services
   *  are not specific to any particular RPC system.  They are generated by the
   *  main code generators in each language (without additional plugins).
   *  Generic services were the only kind of service generation supported by
   *  early versions of google.protobuf.
   *
   *  Generic services are now considered deprecated in favor of using plugins
   *  that generate code specific to your particular RPC system.  Therefore,
   *  these default to false.  Old code which depends on generic services should
   *  explicitly set them to true.
   */
  cc_generic_services?: boolean;
  java_generic_services?: boolean;
  py_generic_services?: boolean;
  php_generic_services?: boolean;
  /**
   *  Is this file deprecated?
   *  Depending on the target platform, this can emit Deprecated annotations
   *  for everything in the file, or it will be completely ignored; in the very
   *  least, this is a formalization for deprecating files.
   */
  deprecated?: boolean;
  /**
   *  Enables the use of arenas for the proto messages in this file. This applies
   *  only to generated classes for C++.
   */
  cc_enable_arenas?: boolean;
  /**
   *  Sets the objective c class prefix which is prepended to all objective c
   *  generated classes from this .proto. There is no default.
   */
  objc_class_prefix?: string;
  /**
   *  Namespace for generated classes; defaults to the package.
   */
  csharp_namespace?: string;
  /**
   *  By default Swift generators will take the proto package and CamelCase it
   *  replacing '.' with underscore and use that to prefix the types/symbols
   *  defined. When this options is provided, they will use this value instead
   *  to prefix the types/symbols defined.
   */
  swift_prefix?: string;
  /**
   *  Sets the php class prefix which is prepended to all php generated classes
   *  from this .proto. Default is empty.
   */
  php_class_prefix?: string;
  /**
   *  Use this option to change the namespace of php generated classes. Default
   *  is empty. When this option is empty, the package name will be used for
   *  determining the namespace.
   */
  php_namespace?: string;
  /**
   *  Use this option to change the namespace of php generated metadata classes.
   *  Default is empty. When this option is empty, the proto file name will be
   *  used for determining the namespace.
   */
  php_metadata_namespace?: string;
  /**
   *  Use this option to change the package of ruby generated classes. Default
   *  is empty. When this option is not set, the package name will be used for
   *  determining the ruby package.
   */
  ruby_package?: string;
  /**
   *  Any features defined in the specific edition.
   */
  features?: TGoogleProtobufFeatureSet;
  /**
   *  The parser stores options it doesn't recognize here.
   *  See the documentation for the "Options" section above.
   */
  uninterpreted_option?: TGoogleProtobufUninterpretedOption[];
}

/**
 * FileOptions
 */
export class FileOptions extends FieldNode {
  //  Sets the Java package where classes generated from this .proto will be
  //  placed.  By default, the proto package is used, but this is often
  //  inappropriate because proto packages do not normally start with backwards
  //  domain names.
  private _javaPackage: STRING;

  //  Controls the name of the wrapper Java class generated for the .proto file.
  //  That class will always contain the .proto file's getDescriptor() method as
  //  well as any top-level extensions defined in the .proto file.
  //  If java_multiple_files is disabled, then all the other classes from the
  //  .proto file will be nested inside the single wrapper outer class.
  private _javaOuterClassname: STRING;

  //  If enabled, then the Java code generator will generate a separate .java
  //  file for each top-level message, enum, and service defined in the .proto
  //  file.  Thus, these types will *not* be nested inside the wrapper class
  //  named by java_outer_classname.  However, the wrapper class will still be
  //  generated to contain the file's getDescriptor() method as well as any
  //  top-level extensions defined in the file.
  private _javaMultipleFiles: BOOLEAN;

  //  This option does nothing.
  private _javaGenerateEqualsAndHash: BOOLEAN;

  //  If set true, then the Java2 code generator will generate code that
  //  throws an exception whenever an attempt is made to assign a non-UTF-8
  //  byte sequence to a string field.
  //  Message reflection will do the same.
  //  However, an extension field still accepts non-UTF-8 byte sequences.
  //  This option has no effect on when used with the lite runtime.
  private _javaStringCheckUtf8: BOOLEAN;

  private _optimizeFor: ENUM<GoogleProtobufFileOptionsOptimizeMode>;

  //  Sets the Go package where structs generated from this .proto will be
  //  placed. If omitted, the Go package will be derived from the following:
  //    - The basename of the package import path, if provided.
  //    - Otherwise, the package statement in the .proto file, if present.
  //    - Otherwise, the basename of the .proto file, without extension.
  private _goPackage: STRING;

  //  Should generic services be generated in each language?  "Generic" services
  //  are not specific to any particular RPC system.  They are generated by the
  //  main code generators in each language (without additional plugins).
  //  Generic services were the only kind of service generation supported by
  //  early versions of google.protobuf.
  //
  //  Generic services are now considered deprecated in favor of using plugins
  //  that generate code specific to your particular RPC system.  Therefore,
  //  these default to false.  Old code which depends on generic services should
  //  explicitly set them to true.
  private _ccGenericServices: BOOLEAN;

  private _javaGenericServices: BOOLEAN;

  private _pyGenericServices: BOOLEAN;

  private _phpGenericServices: BOOLEAN;

  //  Is this file deprecated?
  //  Depending on the target platform, this can emit Deprecated annotations
  //  for everything in the file, or it will be completely ignored; in the very
  //  least, this is a formalization for deprecating files.
  private _deprecated: BOOLEAN;

  //  Enables the use of arenas for the proto messages in this file. This applies
  //  only to generated classes for C++.
  private _ccEnableArenas: BOOLEAN;

  //  Sets the objective c class prefix which is prepended to all objective c
  //  generated classes from this .proto. There is no default.
  private _objcClassPrefix: STRING;

  //  Namespace for generated classes; defaults to the package.
  private _csharpNamespace: STRING;

  //  By default Swift generators will take the proto package and CamelCase it
  //  replacing '.' with underscore and use that to prefix the types/symbols
  //  defined. When this options is provided, they will use this value instead
  //  to prefix the types/symbols defined.
  private _swiftPrefix: STRING;

  //  Sets the php class prefix which is prepended to all php generated classes
  //  from this .proto. Default is empty.
  private _phpClassPrefix: STRING;

  //  Use this option to change the namespace of php generated classes. Default
  //  is empty. When this option is empty, the package name will be used for
  //  determining the namespace.
  private _phpNamespace: STRING;

  //  Use this option to change the namespace of php generated metadata classes.
  //  Default is empty. When this option is empty, the proto file name will be
  //  used for determining the namespace.
  private _phpMetadataNamespace: STRING;

  //  Use this option to change the package of ruby generated classes. Default
  //  is empty. When this option is not set, the package name will be used for
  //  determining the ruby package.
  private _rubyPackage: STRING;

  //  Any features defined in the specific edition.
  private _features: GoogleProtobufFeatureSet;

  //  The parser stores options it doesn't recognize here.
  //  See the documentation for the "Options" section above.
  private _uninterpretedOption: ARRAY<
    GoogleProtobufUninterpretedOption,
    IGoogleProtobufUninterpretedOption
  >;

  public __defaultValues: IFileOptions;

  constructor(
    initData?: IFileOptions,
    parent?: FieldNode,
    parentAttributeName?: string,
  ) {
    super(undefined, parent, parentAttributeName);
    this.__meta.typeName = 'google.protobuf.FileOptions';

    this.__meta.nodeFields = [
      {
        fieldName: 'javaPackage',
        protoName: 'java_package',
        FieldConstructor: STRING,
        constraints: {},
      },
      {
        fieldName: 'javaOuterClassname',
        protoName: 'java_outer_classname',
        FieldConstructor: STRING,
        constraints: {},
      },
      {
        fieldName: 'javaMultipleFiles',
        protoName: 'java_multiple_files',
        FieldConstructor: BOOLEAN,
        constraints: {},
      },
      {
        fieldName: 'javaGenerateEqualsAndHash',
        protoName: 'java_generate_equals_and_hash',
        FieldConstructor: BOOLEAN,
        constraints: {},
      },
      {
        fieldName: 'javaStringCheckUtf8',
        protoName: 'java_string_check_utf8',
        FieldConstructor: BOOLEAN,
        constraints: {},
      },
      {
        fieldName: 'optimizeFor',
        protoName: 'optimize_for',
        FieldConstructor: ENUM<GoogleProtobufFileOptionsOptimizeMode>,
        constraints: {},
      },
      {
        fieldName: 'goPackage',
        protoName: 'go_package',
        FieldConstructor: STRING,
        constraints: {},
      },
      {
        fieldName: 'ccGenericServices',
        protoName: 'cc_generic_services',
        FieldConstructor: BOOLEAN,
        constraints: {},
      },
      {
        fieldName: 'javaGenericServices',
        protoName: 'java_generic_services',
        FieldConstructor: BOOLEAN,
        constraints: {},
      },
      {
        fieldName: 'pyGenericServices',
        protoName: 'py_generic_services',
        FieldConstructor: BOOLEAN,
        constraints: {},
      },
      {
        fieldName: 'phpGenericServices',
        protoName: 'php_generic_services',
        FieldConstructor: BOOLEAN,
        constraints: {},
      },
      {
        fieldName: 'deprecated',
        protoName: 'deprecated',
        FieldConstructor: BOOLEAN,
        constraints: {},
      },
      {
        fieldName: 'ccEnableArenas',
        protoName: 'cc_enable_arenas',
        FieldConstructor: BOOLEAN,
        constraints: {},
      },
      {
        fieldName: 'objcClassPrefix',
        protoName: 'objc_class_prefix',
        FieldConstructor: STRING,
        constraints: {},
      },
      {
        fieldName: 'csharpNamespace',
        protoName: 'csharp_namespace',
        FieldConstructor: STRING,
        constraints: {},
      },
      {
        fieldName: 'swiftPrefix',
        protoName: 'swift_prefix',
        FieldConstructor: STRING,
        constraints: {},
      },
      {
        fieldName: 'phpClassPrefix',
        protoName: 'php_class_prefix',
        FieldConstructor: STRING,
        constraints: {},
      },
      {
        fieldName: 'phpNamespace',
        protoName: 'php_namespace',
        FieldConstructor: STRING,
        constraints: {},
      },
      {
        fieldName: 'phpMetadataNamespace',
        protoName: 'php_metadata_namespace',
        FieldConstructor: STRING,
        constraints: {},
      },
      {
        fieldName: 'rubyPackage',
        protoName: 'ruby_package',
        FieldConstructor: STRING,
        constraints: {},
      },
      {
        fieldName: 'features',
        protoName: 'features',
        FieldConstructor: GoogleProtobufFeatureSet,
        constraints: {},
      },
      {
        fieldName: 'uninterpretedOption',
        protoName: 'uninterpreted_option',
        FieldConstructor: GoogleProtobufUninterpretedOption,
        constraints: {},
      },
    ];

    // Initialize the fields
    //  Sets the Java package where classes generated from this .proto will be
    //  placed.  By default, the proto package is used, but this is often
    //  inappropriate because proto packages do not normally start with backwards
    //  domain names.
    this._javaPackage = new STRING(undefined, this, 'javaPackage');

    //  Controls the name of the wrapper Java class generated for the .proto file.
    //  That class will always contain the .proto file's getDescriptor() method as
    //  well as any top-level extensions defined in the .proto file.
    //  If java_multiple_files is disabled, then all the other classes from the
    //  .proto file will be nested inside the single wrapper outer class.
    this._javaOuterClassname = new STRING(
      undefined,
      this,
      'javaOuterClassname',
    );

    //  If enabled, then the Java code generator will generate a separate .java
    //  file for each top-level message, enum, and service defined in the .proto
    //  file.  Thus, these types will *not* be nested inside the wrapper class
    //  named by java_outer_classname.  However, the wrapper class will still be
    //  generated to contain the file's getDescriptor() method as well as any
    //  top-level extensions defined in the file.
    this._javaMultipleFiles = new BOOLEAN(undefined, this, 'javaMultipleFiles');

    //  This option does nothing.
    this._javaGenerateEqualsAndHash = new BOOLEAN(
      undefined,
      this,
      'javaGenerateEqualsAndHash',
    );

    //  If set true, then the Java2 code generator will generate code that
    //  throws an exception whenever an attempt is made to assign a non-UTF-8
    //  byte sequence to a string field.
    //  Message reflection will do the same.
    //  However, an extension field still accepts non-UTF-8 byte sequences.
    //  This option has no effect on when used with the lite runtime.
    this._javaStringCheckUtf8 = new BOOLEAN(
      undefined,
      this,
      'javaStringCheckUtf8',
    );

    this._optimizeFor = new ENUM<GoogleProtobufFileOptionsOptimizeMode>(
      undefined,
      GoogleProtobufFileOptionsOptimizeMode,
      GoogleProtobufFileOptionsOptimizeMode.SPEED,
      this,
      'optimizeFor',
    );

    //  Sets the Go package where structs generated from this .proto will be
    //  placed. If omitted, the Go package will be derived from the following:
    //    - The basename of the package import path, if provided.
    //    - Otherwise, the package statement in the .proto file, if present.
    //    - Otherwise, the basename of the .proto file, without extension.
    this._goPackage = new STRING(undefined, this, 'goPackage');

    //  Should generic services be generated in each language?  "Generic" services
    //  are not specific to any particular RPC system.  They are generated by the
    //  main code generators in each language (without additional plugins).
    //  Generic services were the only kind of service generation supported by
    //  early versions of google.protobuf.
    //
    //  Generic services are now considered deprecated in favor of using plugins
    //  that generate code specific to your particular RPC system.  Therefore,
    //  these default to false.  Old code which depends on generic services should
    //  explicitly set them to true.
    this._ccGenericServices = new BOOLEAN(undefined, this, 'ccGenericServices');

    this._javaGenericServices = new BOOLEAN(
      undefined,
      this,
      'javaGenericServices',
    );

    this._pyGenericServices = new BOOLEAN(undefined, this, 'pyGenericServices');

    this._phpGenericServices = new BOOLEAN(
      undefined,
      this,
      'phpGenericServices',
    );

    //  Is this file deprecated?
    //  Depending on the target platform, this can emit Deprecated annotations
    //  for everything in the file, or it will be completely ignored; in the very
    //  least, this is a formalization for deprecating files.
    this._deprecated = new BOOLEAN(undefined, this, 'deprecated');

    //  Enables the use of arenas for the proto messages in this file. This applies
    //  only to generated classes for C++.
    this._ccEnableArenas = new BOOLEAN(undefined, this, 'ccEnableArenas');

    //  Sets the objective c class prefix which is prepended to all objective c
    //  generated classes from this .proto. There is no default.
    this._objcClassPrefix = new STRING(undefined, this, 'objcClassPrefix');

    //  Namespace for generated classes; defaults to the package.
    this._csharpNamespace = new STRING(undefined, this, 'csharpNamespace');

    //  By default Swift generators will take the proto package and CamelCase it
    //  replacing '.' with underscore and use that to prefix the types/symbols
    //  defined. When this options is provided, they will use this value instead
    //  to prefix the types/symbols defined.
    this._swiftPrefix = new STRING(undefined, this, 'swiftPrefix');

    //  Sets the php class prefix which is prepended to all php generated classes
    //  from this .proto. Default is empty.
    this._phpClassPrefix = new STRING(undefined, this, 'phpClassPrefix');

    //  Use this option to change the namespace of php generated classes. Default
    //  is empty. When this option is empty, the package name will be used for
    //  determining the namespace.
    this._phpNamespace = new STRING(undefined, this, 'phpNamespace');

    //  Use this option to change the namespace of php generated metadata classes.
    //  Default is empty. When this option is empty, the proto file name will be
    //  used for determining the namespace.
    this._phpMetadataNamespace = new STRING(
      undefined,
      this,
      'phpMetadataNamespace',
    );

    //  Use this option to change the package of ruby generated classes. Default
    //  is empty. When this option is not set, the package name will be used for
    //  determining the ruby package.
    this._rubyPackage = new STRING(undefined, this, 'rubyPackage');

    //  Any features defined in the specific edition.
    this._features = new GoogleProtobufFeatureSet(undefined, this, 'features');

    //  The parser stores options it doesn't recognize here.
    //  See the documentation for the "Options" section above.
    this._uninterpretedOption = new ARRAY<
      GoogleProtobufUninterpretedOption,
      IGoogleProtobufUninterpretedOption
    >(undefined, this, 'uninterpretedOption');

    // Set required fields
    [].forEach(fieldName => {
      (this[fieldName as keyof FileOptions] as FieldNode).__meta.required =
        true;
    });

    // Default values from openAPI annotations
    this.__defaultValues = {};

    // Initialize the fields with init data
    if (initData !== undefined) {
      this.__fromLiteral({ ...this.__defaultValues, ...initData });
    } else {
      this.__fromLiteral(this.__defaultValues);
    }

    // Set readonly fields after the init, so child nodes are readonly too
    [].forEach(fieldName => {
      (this[fieldName as keyof FileOptions] as FieldNode).__readonly = true;
    });

    this.__meta.isPristine = true;
  }

  //  Sets the Java package where classes generated from this .proto will be
  //  placed.  By default, the proto package is used, but this is often
  //  inappropriate because proto packages do not normally start with backwards
  //  domain names.
  public get javaPackage(): STRING {
    return this._javaPackage;
  }

  public set javaPackage(v: string) {
    this.__PrimitivesSetter(this._javaPackage, v);
  }

  //  Controls the name of the wrapper Java class generated for the .proto file.
  //  That class will always contain the .proto file's getDescriptor() method as
  //  well as any top-level extensions defined in the .proto file.
  //  If java_multiple_files is disabled, then all the other classes from the
  //  .proto file will be nested inside the single wrapper outer class.
  public get javaOuterClassname(): STRING {
    return this._javaOuterClassname;
  }

  public set javaOuterClassname(v: string) {
    this.__PrimitivesSetter(this._javaOuterClassname, v);
  }

  //  If enabled, then the Java code generator will generate a separate .java
  //  file for each top-level message, enum, and service defined in the .proto
  //  file.  Thus, these types will *not* be nested inside the wrapper class
  //  named by java_outer_classname.  However, the wrapper class will still be
  //  generated to contain the file's getDescriptor() method as well as any
  //  top-level extensions defined in the file.
  public get javaMultipleFiles(): BOOLEAN {
    return this._javaMultipleFiles;
  }

  public set javaMultipleFiles(v: boolean) {
    this.__PrimitivesSetter(this._javaMultipleFiles, v);
  }

  //  This option does nothing.
  public get javaGenerateEqualsAndHash(): BOOLEAN {
    return this._javaGenerateEqualsAndHash;
  }

  public set javaGenerateEqualsAndHash(v: boolean) {
    this.__PrimitivesSetter(this._javaGenerateEqualsAndHash, v);
  }

  //  If set true, then the Java2 code generator will generate code that
  //  throws an exception whenever an attempt is made to assign a non-UTF-8
  //  byte sequence to a string field.
  //  Message reflection will do the same.
  //  However, an extension field still accepts non-UTF-8 byte sequences.
  //  This option has no effect on when used with the lite runtime.
  public get javaStringCheckUtf8(): BOOLEAN {
    return this._javaStringCheckUtf8;
  }

  public set javaStringCheckUtf8(v: boolean) {
    this.__PrimitivesSetter(this._javaStringCheckUtf8, v);
  }

  public get optimizeFor(): ENUM<GoogleProtobufFileOptionsOptimizeMode> {
    return this._optimizeFor;
  }

  public set optimizeFor(v: GoogleProtobufFileOptionsOptimizeMode) {
    this.__TypeSetter(this._optimizeFor, v);
  }

  //  Sets the Go package where structs generated from this .proto will be
  //  placed. If omitted, the Go package will be derived from the following:
  //    - The basename of the package import path, if provided.
  //    - Otherwise, the package statement in the .proto file, if present.
  //    - Otherwise, the basename of the .proto file, without extension.
  public get goPackage(): STRING {
    return this._goPackage;
  }

  public set goPackage(v: string) {
    this.__PrimitivesSetter(this._goPackage, v);
  }

  //  Should generic services be generated in each language?  "Generic" services
  //  are not specific to any particular RPC system.  They are generated by the
  //  main code generators in each language (without additional plugins).
  //  Generic services were the only kind of service generation supported by
  //  early versions of google.protobuf.
  //
  //  Generic services are now considered deprecated in favor of using plugins
  //  that generate code specific to your particular RPC system.  Therefore,
  //  these default to false.  Old code which depends on generic services should
  //  explicitly set them to true.
  public get ccGenericServices(): BOOLEAN {
    return this._ccGenericServices;
  }

  public set ccGenericServices(v: boolean) {
    this.__PrimitivesSetter(this._ccGenericServices, v);
  }

  public get javaGenericServices(): BOOLEAN {
    return this._javaGenericServices;
  }

  public set javaGenericServices(v: boolean) {
    this.__PrimitivesSetter(this._javaGenericServices, v);
  }

  public get pyGenericServices(): BOOLEAN {
    return this._pyGenericServices;
  }

  public set pyGenericServices(v: boolean) {
    this.__PrimitivesSetter(this._pyGenericServices, v);
  }

  public get phpGenericServices(): BOOLEAN {
    return this._phpGenericServices;
  }

  public set phpGenericServices(v: boolean) {
    this.__PrimitivesSetter(this._phpGenericServices, v);
  }

  //  Is this file deprecated?
  //  Depending on the target platform, this can emit Deprecated annotations
  //  for everything in the file, or it will be completely ignored; in the very
  //  least, this is a formalization for deprecating files.
  public get deprecated(): BOOLEAN {
    return this._deprecated;
  }

  public set deprecated(v: boolean) {
    this.__PrimitivesSetter(this._deprecated, v);
  }

  //  Enables the use of arenas for the proto messages in this file. This applies
  //  only to generated classes for C++.
  public get ccEnableArenas(): BOOLEAN {
    return this._ccEnableArenas;
  }

  public set ccEnableArenas(v: boolean) {
    this.__PrimitivesSetter(this._ccEnableArenas, v);
  }

  //  Sets the objective c class prefix which is prepended to all objective c
  //  generated classes from this .proto. There is no default.
  public get objcClassPrefix(): STRING {
    return this._objcClassPrefix;
  }

  public set objcClassPrefix(v: string) {
    this.__PrimitivesSetter(this._objcClassPrefix, v);
  }

  //  Namespace for generated classes; defaults to the package.
  public get csharpNamespace(): STRING {
    return this._csharpNamespace;
  }

  public set csharpNamespace(v: string) {
    this.__PrimitivesSetter(this._csharpNamespace, v);
  }

  //  By default Swift generators will take the proto package and CamelCase it
  //  replacing '.' with underscore and use that to prefix the types/symbols
  //  defined. When this options is provided, they will use this value instead
  //  to prefix the types/symbols defined.
  public get swiftPrefix(): STRING {
    return this._swiftPrefix;
  }

  public set swiftPrefix(v: string) {
    this.__PrimitivesSetter(this._swiftPrefix, v);
  }

  //  Sets the php class prefix which is prepended to all php generated classes
  //  from this .proto. Default is empty.
  public get phpClassPrefix(): STRING {
    return this._phpClassPrefix;
  }

  public set phpClassPrefix(v: string) {
    this.__PrimitivesSetter(this._phpClassPrefix, v);
  }

  //  Use this option to change the namespace of php generated classes. Default
  //  is empty. When this option is empty, the package name will be used for
  //  determining the namespace.
  public get phpNamespace(): STRING {
    return this._phpNamespace;
  }

  public set phpNamespace(v: string) {
    this.__PrimitivesSetter(this._phpNamespace, v);
  }

  //  Use this option to change the namespace of php generated metadata classes.
  //  Default is empty. When this option is empty, the proto file name will be
  //  used for determining the namespace.
  public get phpMetadataNamespace(): STRING {
    return this._phpMetadataNamespace;
  }

  public set phpMetadataNamespace(v: string) {
    this.__PrimitivesSetter(this._phpMetadataNamespace, v);
  }

  //  Use this option to change the package of ruby generated classes. Default
  //  is empty. When this option is not set, the package name will be used for
  //  determining the ruby package.
  public get rubyPackage(): STRING {
    return this._rubyPackage;
  }

  public set rubyPackage(v: string) {
    this.__PrimitivesSetter(this._rubyPackage, v);
  }

  //  Any features defined in the specific edition.
  public get features(): GoogleProtobufFeatureSet {
    return this._features;
  }

  public set features(v: IGoogleProtobufFeatureSet) {
    this.__TypeSetter(this._features, v);
  }

  //  The parser stores options it doesn't recognize here.
  //  See the documentation for the "Options" section above.
  public get uninterpretedOption(): ARRAY<
    GoogleProtobufUninterpretedOption,
    IGoogleProtobufUninterpretedOption
  > {
    return this._uninterpretedOption;
  }

  public set uninterpretedOption(v: IGoogleProtobufUninterpretedOption[]) {
    this.__TypeSetter(this._uninterpretedOption, v);
  }

  fromLiteral(data: IFileOptions) {
    super.__fromLiteral(data);
  }

  toLiteral(): IFileOptions {
    return super.__toLiteral();
  }
}

Registry.register('google.protobuf.FileOptions', FileOptions);
